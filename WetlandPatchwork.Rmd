Disaggregating the Patchwork: 
=============================
Bayesian hierarchical models as tools to predict wetland presence across a continuous gradient
---------------------------------------------------------------------------------------------


####Authors:
John Humphreys,  
Dr. James Elsner,  
AmirSassan Mahjoor




```{r}
date()
version$platform
version$version.string
```





#Model Fitting for Initial Domain

###Load Primary Packages:
```{r}
suppressMessages(library(rgdal))
suppressMessages(library(raster))
suppressMessages(library(rasterVis))
suppressMessages(library(rgeos))
suppressMessages(library(GISTools))
suppressMessages(library(maptools))
suppressMessages(library(ggplot2))
suppressMessages(library(ggmap))
suppressMessages(library(maps))
suppressMessages(library(grid))
suppressMessages(library(colorRamps))
suppressMessages(library(RColorBrewer))
suppressMessages(library(spdep))
suppressMessages(library(corrplot))
suppressMessages(library(gridExtra))
suppressMessages(library(reshape2))
suppressMessages(library(plyr))
suppressMessages(library(dplyr))
```


###Get Project Data
The link provided below will download all of the data needed to run this script.  The data and copies of the R-Markdown files are available at:https://github.com/JMHumphreys/WetlandPatchwork
```{r}
url = "ftp://ftp.dep.state.fl.us/pub/outgoing/EPA_WPDG_2013/WetlandData.zip"
  
  download.file(url, "WetlandData.zip", mode = "wb")
  unzip("WetlandData.zip")
```


###Figure 1 (Study Area Domain)
The domain for this study is shown below.  The area is centered on Wakulla Springs State Park in Wakulla County, Florida.  The areal extent of the domain is approximately 100km^2 and is bounded by a 10km X 10km square.
```{r}
#Domain (shapefile)
Domain100 = readOGR(dsn = "./WetlandData/Domains/Domain100", 
                    layer = "Domain100", 
                    stringsAsFactors = FALSE, 
                    p4s = "+proj=utm +zone=17 +datum=NAD83")
                    gIsValid(Domain100)
                    Domain100 = gBuffer(Domain100, width=0, byid=TRUE)
```

```{r}
Map = get_map(location = c(-84.27, 30.20), 
              source = "google",
              zoom = 12,
              color = "color",
              maptype = "terrain")
p1 = ggmap(Map, dev = "extent") +
  geom_segment(aes(x = -84.31977,
                   xend = -84.21574,
                   y = 30.25513,
                   yend = 30.25513), 
             color = "red") +
  geom_segment(aes(x = -84.31977,
                   xend = -84.21574,
                   y = 30.16491,
                   yend = 30.16491), 
             color = "red") +
  geom_segment(aes(x = -84.31977,
                   xend = -84.31977,
                   y = 30.25513,
                   yend = 30.16491), 
             color = "red") +
  geom_segment(aes(x = -84.21574 ,
                   xend = -84.21574,
                   y = 30.25513,
                   yend = 30.16491), 
             color = "red") + 
  labs(x = expression(paste("Longitude (", degree, "W)")), 
       y = expression(paste("Latitude (", degree, "N)")))

source('./WetlandData/ScaleBar/ScaleBarNorth.R')

p1b = p1 + scaleBar(lon = -84.37,
                    lat = 30.107, 
                    distanceLon = 5,
                    distanceLat = 1,
                    distanceLegend = 1.5,
                    dist.unit = "km",
                    arrow.length = 3,
                    arrow.distance = 2,
                    arrow.North.size = 12)

p1b + theme(panel.grid.minor = element_line(colour = NA), 
            panel.grid.minor = element_line(colour = NA),
            panel.background = element_rect(fill = NA, colour = NA), 
            rect = element_blank())
```



###Domain Target Cell Size (TCS)
This script will produce several raster objects.  The target raster cell size in meters may be adjusted by typing the targeted cell dimensions (cell edge length) into the "TCS" variable below.  
```{r}
TCS = 50 #Raster cell edge length (meters)

xCOL = ceiling(10000/TCS)
yROW = ceiling(10000/TCS)
```



###Read Soil and Landuse/Landcover Shapefiles
The shapefiles are downloaded and then cropped to the domain extent.

The first shapefile is soils data (polygons) from the USDA NRCS (SSURGO Soil Mapping Units 2011).
The data is freely available here: http://www.arcgis.com/home/item.html?id=a23eb436f6ec4ad6982000dbaddea5ea
or http://websoilsurvey.sc.egov.usda.gov/App/HomePage.htm

Descriptions of included soil attributes are available here: 
http://sdmdataaccess.nrcs.usda.gov/documents/TableColumnDescriptionsReport.pdf

The second shapefile is Landcover/Landuse polygons for NW Florida (FDEP 2012).
The lc/lu data is freely available here: http://www.dep.state.fl.us/gis/datadir.htm
```{r}
#Soils Data
         Raw_Soils = readOGR(dsn = "./WetlandData/SSURGO_NWF", 
                             layer = "SSURGO_NWF", 
                             stringsAsFactors = FALSE, 
                             p4s = "+proj=utm +zone=17 +datum=NAD83")
                             Raw_Soils.spdf = crop(Raw_Soils, Domain100) 
                             gIsValid(Raw_Soils.spdf) #Chk TopologY
                             Raw_Soils.spdf = gBuffer(Raw_Soils.spdf, width=0, byid=TRUE) #Fix Topology

#Landcover/Landuse Data
         LCLU_NWF = readOGR(dsn = "./WetlandData/LCLU_NWF", 
                            layer = "LCLU_NWF", 
                            stringsAsFactors = FALSE, 
                            p4s = "+proj=utm +zone=17 +datum=NAD83")
                            LCLU_NWF.spdf = crop(LCLU_NWF, Domain100) 
                            gIsValid(LCLU_NWF.spdf)
                            LCLU_NWF.spdf = gBuffer(LCLU_NWF.spdf, width=0, byid=TRUE)   
```


###Subset Landcover Groups
Subset the Landuse/Landcover shapefile into two broad groups:
Natural Uplands (UP_LC.spdf)
Natural Wetlands and Surface Waters (Wet_LC.spdf)

The conditional values used to subset were derived from the 
Florida Land Use/Cover Classification System (FLUCCS)
```{r}    
UP_LC.spdf = subset(LCLU_NWF.spdf, 
                    LANDUSE_CO >= 2600 & 
                    LANDUSE_CO <= 4430 )

Wet_LC.spdf = subset(LCLU_NWF.spdf, 
                     LANDUSE_CO >= 5000 & 
                     LANDUSE_CO <= 6999 )
```


###Crop soils data
Crop the extent of the soils polygons to areas identified as natural upland and 
Wetland landcover types (spatially subset).  This distinguishes upland associated soils from 
wetland associated soils.

Add a column ("Designation") to the soils dataset to designate Wetland ("1") from Upland ("0") associated areas.
```{r}
UP_Soils.spdf = crop(Raw_Soils.spdf, UP_LC.spdf) 
UP_Soils.spdf@data = UP_Soils.spdf@data %>%
                     mutate(Designation = 0)


Wet_Soils.spdf = crop(Raw_Soils.spdf, Wet_LC.spdf)
Wet_Soils.spdf@data = Wet_Soils.spdf@data %>%
                      mutate(Designation = 1)
```

Combine wetland and upland shapefiles to create a combined set of mapped soil units for natural wetlands and uplands. 
Developed areas have now been removed - these are "non-soil" areas. 
```{r}
UP_Soils1.spdf = spChFIDs(UP_Soils.spdf, 
                          paste(as.character(
                                1:nrow(UP_Soils.spdf)),"U", sep = ""))

Wet_Soils1.spdf = spChFIDs(Wet_Soils.spdf, 
                           paste(as.character(
                                1:nrow(Wet_Soils.spdf)),"W", sep = ""))

Soils.spdf = spRbind(UP_Soils1.spdf, Wet_Soils1.spdf)

Soils.spdf$IDs = 1:nrow(Soils.spdf)
```


###Prior Distribution
To quantify current understanding.
```{r}
D0 = 0.33 #Prob of wetlands in Florida
D1 = 0.50 #Prop of being wetland if known to have wetland vegetation

Soils.spdf$Extent = gArea(Soils.spdf,
                          byid = TRUE)

Wet_area = as.numeric(
             Soils.spdf@data %>%
                       filter(Designation == 1) %>%
                       summarise(sum(Extent, na.rm = TRUE)))

Up_area = as.numeric(
            Soils.spdf@data %>%
                      filter(Designation == 0) %>%
                      summarise(sum(Extent, na.rm = TRUE)))

Wp = (Wet_area/(Wet_area + Up_area))
Up = (Up_area/(Wet_area + Up_area))

Pr = (Up*D0) + (Wp*D1)
```
The beta density is then used to quantify prior belief about the chance of wetland presence.

$f(pi)$  is proportional to  $\pi^{(a-1)} \times (1 - \pi)^{(b-1)}$

where "a" (scale) and "b" (shape) are parameters of the distribution.  Like the mean a variance for a normal density. The beta parameters can be re-expressed in terms of means and variance. The mean is m = a/(a + b) and the variance is v = m * (1 - m)/(a + b + 1).  

The beta.select() function in the *LearnBayes* package (Albert 2011) is useful for finding the two parameters (shape and scale) of the beta density that match prior knowledge (the median is "Pr" and the 90th percentile is 0.5.  The inputs are two lists, q1 and q2, that define these two percentiles, and the function returns the values of the corresponding beta parameters, "a" and "b" The argument "p" is the percentile and the argument "x" is a value for pi.
```{r}
suppressMessages(library(LearnBayes))

q1 = list(p = .5, x = Pr)
q2 = list(p = .9, x = D1)
B.select = beta.select(q1, q2) 

a = B.select[1]
b = B.select[2]
```

Record the prior distribution as the list object "hyper.p" specifying the beta distribution.
The logitbeta-prior is defined on theta so that the probability parameter "p" has a Beta(a, b) distribution.
```{r}
hyper.p = list(prec = list(
                        list(prior = "logitbeta", 
                             param = c(a, b),
                             initial = 0)))
```

Plot the Prior Distribution
```{r}
curve(dbeta(x, a, b), 
      from = 0, to = 1, 
      xlab = "Probabilty of Wetland (Prior)", 
      ylab = "Density", 
      cex.lab  = 1,
      lwd = 5, las = 1,
      col="black")
abline(v = .5, lty = 2)
abline(v = Pr, lty = 2)
```


###Combine Upland and Wetland Data Frames
Extract a data frame from Soils.spdf and drop a few redundant columns in preparation for subsequent
Principal Components Analysis (PCA) and Multiple Correspondence Analysis (MCA).

Ensure that MCA variables are Factor and those for PCA are numeric.
```{r}
Soils.df = Soils.spdf@data

Soils0.df = subset(Soils.df, 
                   select = -c(AREASYMBOL,  SPATIALVER, NationalMu,  
                                muhelcl,  muwathelcl,  muwndhelcl,  interpfocu, 
                                invesinten,  lkey,  iacornsr,  projectsca,  tabularver, 
                                iccdcd,   iccdcdpct,  engstafdcd,  engstafll,  engstafml, 
                                albedo_h,  albedo_l,  cropprodin,  rsprod_h,  rsprod_l, 
                                rsprod_r,  slopelen_h,  slopelen_l,  cokey,  comppct_l,   
                                comppct_h,  compkind,  earthcovki,  earthcov_1,  aspectccwi, 
                                aspectrep,  aspectcwis,  geomdesc,  nirrcapuni,  irrcapcl, 
                                irrcapscl,  irrcapunit,  constreesh,  soilslippo,  frostact, 
                                soiltaxedi,  taxclname,  taxorder,  taxsuborde,  taxgrtgrou, 
                                taxsubgrp,  taxparts_1, map_h,  map_l,	map_r, Shape_Leng, Shape_Area))

Soils1.df = as.data.frame(lapply
                          (Soils0.df, factor))
Soils2.df = Soils1.df %>%
            mutate(Designation = as.numeric(Soils.df$Designation),
                   IDs = as.numeric(Soils.df$IDs),
                   wtdepaprju = as.numeric(round(Soils.df$wtdepaprju),5),
                   wtdepannmi = as.numeric(round(Soils.df$wtdepannmi),5),
                   slopegradd = as.numeric(round(Soils.df$slopegradd),5),
                   slopegradw = as.numeric(round(Soils.df$slopegradw), 5),
                   aws025wta = as.numeric(round(Soils.df$aws025wta), 5),
                   aws050wta = as.numeric(round(Soils.df$aws050wta), 5),
                   aws0100wta = as.numeric(round(Soils.df$aws0100wta), 5),
                   aws0150wta = as.numeric(round(Soils.df$aws0150wta), 5),
                   niccdcdpct = as.numeric(round(Soils.df$niccdcdpct), 5),
                   albedo_r = as.numeric(round(Soils.df$albedo_r), 5),
                   elev_h = as.numeric(round(Soils.df$elev_h), 5),
                   elev_l = as.numeric(round(Soils.df$elev_l), 5),
                   elev_r = as.numeric(round(Soils.df$elev_r), 5),
                   slope_h = as.numeric(round(Soils.df$slope_h), 5),
                   slope_r = as.numeric(round(Soils.df$niccdcdpct), 5))
```


###Conduct Principal Components Analysis (PCA)
This exploratory statistic for continuous numeric variables is used to reduce dimensionality for
later Bayesian analysis.

*FactoMineR* is used to run the procedure, the developer's website: 
http://factominer.free.fr/classical-methods/multiple-correspondence-analysis.html

First subset variables (columns) to be included in the PCA, then run the PCA()
``` {r}
suppressMessages(library(FactoMineR))

Soils.PCA = Soils2.df %>%
                select(slopegradd, slopegradw, aws025wta, aws050wta, aws0100wta,
                aws0150wta, niccdcdpct, albedo_r, elev_h, elev_l, elev_r, slope_h, 
                slope_r, wtdepaprju, wtdepannmi)

PCA.Result = PCA(Soils.PCA , 
                 scale.unit = TRUE, 
                 ncp = 5, 
                 graph = FALSE)
```


###Singular Value Decomposition (SVD) to Data Frame
```{r}
PCA.df = as.data.frame(PCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```
 

###Explore PCA Results for Significant Values
Run a series of non-spatial, Bayesian models to investigate explanatory power.

Decomposed dimensions from the PCA in which zero falls outside of the credible interval are retained for possible model inclusion.
```{r}
#source("http://www.math.ntnu.no/inla/givemeINLA.R")
#update.packages("INLA")
suppressMessages(library("INLA"))
```

```{r}
Form1 = Designation ~ V1 + V2 + V3 + V4 + V5

PCAmod  =  inla(Form1, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = PCA.df)

summary(PCAmod)
PCAmod$dic$dic

Form1a = Designation ~ V1 + V2 + V3

PCAmod2  =  inla(Form1a, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = PCA.df)
summary(PCAmod2)
PCAmod2$dic$dic

```


###Conduct Multiple Correspondance Analysis (MCA)
The MCA is similar a Principal Components Analysis (PCA); but, for nominal datasets.
As with the PCA, this exploratory statistic is used to narrow variables for later Bayesian analysis.

First subset variables (columns) to be included in the MCA, then run the MCA()
``` {r}
Soils.MCA = Soils2.df %>%
               select(MUSYM, muname, mukind, farmlndcl, museq, brockdepmi, 
                      flodfreqdc, flodfreqma, pondfreqpr, drclassdcd, 
                      drclasswet, hydgrpdcd, niccdcd, engdwobdcd, engdwbdcd,  engdwbll,  
                      engdwbml,   engsldcd,   engsldcp, englrsdcd,  engcmssdcd, engcmssmp, 
                      urbrecptdc, urbrecptwt, forpehrtdc, hydclprs, awmmfpwwta, airtempa_h, 
                      airtempa_l, airtempa_r, ffd_h, ffd_l, ffd_r, initsub_h, initsub_l, 
                      initsub_r, slope_l, slopelen_r, totalsub_h, totalsub_l, totalsub_r, 
                      compname, otherph, localphase, runoff, tfact, wei, weg, erocl, 
                      hydricon, nirrcapcl, nirrcapscl, foragesuit, wlgrai, wlgrass, wlherbaceo,
                      wlshrub, wlconifero, wlhardwood, wlwetplant, wlshalloww, wlrangelan, 
                      wlopenland, wlwoodland, wlwetland, corcon, corsteel, taxpartsiz, 
                      taxceactcl, taxreactio, taxtempcl, taxmoistsc, taxtempreg)

MCA.Result = MCA(Soils.MCA, 
                 ncp=5, 
                 graph = FALSE)
```

###MCA Singular Value Decomposition (SVD) to .df
Pull SVD values from the MCA and add the associated Wetland/Upland "Designation" in a new data frame.
```{r}
MCA.df = as.data.frame(MCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```


###Explore MCA Results for Significant Values
As with the PCA, the explanatory power of values from the MCA are explored.

Decomposed dimensions from the MCA in which zero falls outside of the credible interval are retained for possible model inclusion.
```{r}
Form2 = Designation ~ V1 + V2 + V3 + V4 + V5

MCAmod  =  inla(Form2, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = MCA.df)

summary(MCAmod)
MCAmod$dic$dic

Form2a = Designation ~ V3

MCAmod2  =  inla(Form2a, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = MCA.df)
summary(MCAmod2)
MCAmod2$dic$dic

```


###Combine Significant MCA and PCA Results
Attach the significant MCA and PCA results to Soils2.spdf.

Also added is the "MUKEY" column from the Soils.spdf that will be used to explore additional soils data later.
```{r}
Soils2.spdf = Soils.spdf

Soils2.spdf@data = PCA.df %>%
                   select(Designation, V1, V2, V3) %>%
                   mutate(MCA3 = MCA.df[,"V3"],
                          MUKEY = as.numeric(Soils.spdf@data[,"MUKEY"]))
```


###Convert Soils PCA and MCA Results to Raster Objects
First, create a raster template based on the resolution specified at top of the script.
```{r}
Blank.r = raster(nrows = yROW, ncols = xCOL)
extent(Blank.r) = extent(Soils2.spdf)
proj4string(Blank.r) = proj4string(Soils2.spdf)
```


###Create Wetland/Upland Designation Raster
```{r}
w_rast = rasterize(Wet_Soils.spdf,
                   Blank.r,
                   field = 1)

w_rast = reclassify(w_rast,
                    cbind(NA, 0))
```


###Create Rasters for Significatnt PCA/MCA Results
```{r}
V1_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V1)

V2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V2)

V3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V3)

MCA3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$MCA3)
```


###Convert Rasters to SpatialPolygonsDataFrame
Add PCA and MCA results
```{r}
Wetlands.spdf = as(w_rast, "SpatialPolygonsDataFrame")
names(Wetlands.spdf) = "Designation"

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(V1 = values(V1_rast),
                               V2 = values(V2_rast),
                               V3 = values(V3_rast),
                               MCAV3 = values(MCA3_rast))
```


###Soil Available Water Capacity (AWC) and Organic Mass (OM)
The soils attribute "awc_r" describes the amount of water that an increment of soil depth (inclusive of fragments) can store that is available to plants and can be used to calculate an "AWC".  AWC is expressed as a volume fraction, and is commonly estimated as the difference between the water contents at 1/10 or 1/3 bar (field capacity) and 15 bars (permanent wilting point) tension and adjusted for salinity, and fragments.  AWC is often used to estimate Available Water Storage.

The soils attribute "OM_r" describes the amount (by weight) of decomposed plant and animal residue expressed as a weight percentage of the less than 2 mm soil material.  The "Organic Mass" variable is commonly used to estimate Soil Organic Carbon content.

The "awc_r" and "OM_r" variables were not included in the soils data explored so far - though they are used to estimate some of the explored soils attributes.  These are downloaded for the study domain from the NRCS "live" database; they're then averaged by soil horizon, soil profile, and Soil Mapping Unit.
###Additional Libraries are Needed
```{r}
#install.packages('Hmisc', dep=TRUE)
suppressMessages(library(Hmisc))

#install.packages('soilDB', dep=TRUE) #from CRAN + dependencies
#install.packages("soilDB", repos="http://R-Forge.R-project.org") # most recent from r-forge
suppressMessages(library(soilDB))

#install.packages("SSOAP", repos = "http://www.omegahat.org/R", type="source") # SSOAP, XMLSchema
suppressMessages(library(SSOAP))
```


###Query Function
This function has been modified from the "SDA_Query()" included with the *SoilDB* package.
```{r}
SDAquery = function (q) 
{
    if (!requireNamespace("SSOAP", quietly = TRUE) | !requireNamespace("XMLSchema", 
        quietly = TRUE)) 
        stop("please install the `SSOAP` and `XMLSchema` packages", 
            call. = FALSE)
    opt.original <- options(stringsAsFactors = FALSE)
    s <- SSOAP::SOAPServer("SDMDataAccess.nrcs.usda.gov", "/Tabular/SDMTabularService.asmx")
    a <- I("http://SDMDataAccess.nrcs.usda.gov/Tabular/SDMTabularService.asmx/RunQuery")
    x <- c(I("http://SDMDataAccess.nrcs.usda.gov/Tabular/SDMTabularService.asmx"))
    cat("sending SOAP request...\n")
    res <- SSOAP::.SOAP(s, "RunQuery", 
                        Query = q, 
                        action = a, 
                        xmlns = x)
    cat("processing results...\n")
    df <- ldply(res$diffgram$NewDataSet, .fun = cleanSDA, .progress = "none")
    df$.id <- NULL
    f <- tempfile()
    write.table(df, file = f, col.names = TRUE, row.names = FALSE, 
        quote = FALSE, sep = "|")
    df <- read.table(f, header = TRUE, sep = "|", quote = "", 
        comment.char = "")
    options(opt.original)
    return(df)
}
```


###Rasterize MUKEY 
The Mapped Unit Keys (MUKEY) are used to identify locations of Mapped Soils Units in the study domain. 
```{r}
AWC.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)

OM.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)
```

###Soil Functions
These functions will be used for aggregating horizon-level data within each map unit. 

The first two will profile AWC and OM values by soil horizon.
```{r}
HzWS = function(i) {
              wt = i$comppct_r[1]  
              thick = with(i, hzdepb_r - hzdept_r)  
              whc = thick * i$awc_r 
            	whc.total = sum(whc, na.rm=TRUE)  
	            data.frame(whc = whc.total, wt=wt)  
}

HzWSO = function(i) {
              wto = i$comppct_r[1]  
              thicko = with(i, hzdepb_r - hzdept_r)  
              whco = thicko * i$Om_r  
            	whc.totalo = sum(whco, na.rm=TRUE)   
	            data.frame(whco = whc.totalo, wto=wto)  
}
```

The next two functions find the average (weighted by component percentage) within each Soil Map Unit
```{r}
MU_mean = function(i) {
	              whc = wtd.mean(i$whc, weights=i$wt) 
	              data.frame(whc=whc)  
}

MU_meano = function(i) {
	              whco = wtd.mean(i$whco, weights=i$wto)  
	              data.frame(whco=whco)  
}
```

###Add Raster Attribute Table (RAT)
```{r}
AWC.r = ratify(AWC.r,
               count = TRUE)

OM.r = ratify(OM.r,
               count = TRUE)
```

###save RATs as Objects
```{r}
rat = levels(AWC.r)[[1]]

rato = levels(OM.r)[[1]]
```

###Extract MUKEYs from the RAT
To be used in a SQL "IN-statement" to query the soils database.
```{r}
in.statement = format_SQL_in_statement(rat$ID)

in.statement2 = format_SQL_in_statement(rato$ID)
```


###Query SDA
Submit a data SQL query to the Soil Data Access server (SDA); requesting horizon-level data.
```{r}
q = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

ACW.res = SDAquery(q) 
```

```{r}
q2 = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

OM.res = SDAquery(q2)
```


###Aggregate Data
Running custom soil functions.
```{r}
co.whc = ACW.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWS(.))

mu.whc = co.whc %>% 
              group_by(mukey) %>% 
              do(MU_mean(.))

co.whco = OM.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWSO(.))

mu.whco = co.whco %>% 
              group_by(mukey) %>% 
              do(MU_meano(.))
```

###Join Results to Domain Rasters
```{r}
names(mu.whc)[1] = 'ID'
rat.new = left_join(rat, mu.whc)
levels(AWC.r) = rat.new
AWC = deratify(AWC.r, att='whc')

names(mu.whco)[1] = 'ID'
rato.new = left_join(rato, mu.whco)
levels(OM.r) = rato.new
OM = deratify(OM.r, att='whco')
```


###Add Results to Wetlands.spdf
```{r}
Wetlands.spdf$AWC = values(AWC)
Wetlands.spdf$OM = values(OM)
```


###Verify Significance
```{r}
Form3 = Designation ~ AWC

AWCmod  =  inla(Form3, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(AWCmod)
AWCmod$dic$dic


Form4 = Designation ~ OM

OMmod  =  inla(Form4, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(OMmod)
OMmod$dic$dic




```



###Soil Adjusted Vegetation Index (SAVI)
Reflectance data from the LandSat8 Satellite is used to calculate a Soil Adjusted Vegetation Index (SAVI).
The data is freely available from the USGS and can be accessed here: http://landsat.usgs.gov/landsat8.php

The SAVI is calculated as the ratio between the Red (R) and Near Infrared (NIR) values from the LandSat8 Satellite with a soil brightness correction factor (L) defined as 0.5 to accommodate most land cover types: ((NIR - R) / (NIR + R + L)) * (1 + L)
```{r}
Band4 = raster("./WetlandData/LS8/ls8_band4/w001001.adf")

Band5 = raster("./WetlandData/LS8/ls8_band5/w001001.adf")
      
savi = ((Band5 - Band4) / (Band5 + Band4 + 0.5)) * (1.5)

DomainB = readOGR(dsn = "./WetlandData/Domains/Domain100", 
                  layer = "Domain100", 
                  stringsAsFactors = FALSE)

DomainBp = spTransform(DomainB, 
                       CRS(projection(savi)))

savi100 = crop(savi, DomainBp)
extent(savi100) = extent(Blank.r)

SAVI = resample(savi100, Blank.r, 
                method = 'bilinear')

Wetlands.spdf$SAVI = values(SAVI)
```


###Verify Significance of SAVI
```{r}
Form5 = Designation ~ SAVI

SAVImod  =  inla(Form5, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(SAVImod)
SAVImod$dic$dic
```


###Explanatory Variables linked to Topograpy 
The preceding analysis served to identify soil and vegetative related attributes.  Next, explore topographic data to identify additional explanatory variables related to hydrology.

The calculations bellow incorporate the the 1/3 arc-second Digital Elevation Model from the National Elevation Dataset, which is freely available here:  http://ned.usgs.gov/

Read DEM data and crop to domain.
```{r}
#DEM (USGS 1/3 arc-sec)
      DEM = raster("./WetlandData/DEM_NWF/dem_nwf/w001001.adf")
      DEM = reclassify(DEM, 
                        cbind(0, 0.001))
      
      DomainBp = spTransform(DomainB, 
                 CRS(projection(DEM)))
      
      DEM = crop(DEM, DomainBp)
```


###Calculate Topographic Indicies
The Topographic Position Index (TPI) is often used to classify different landscape morphologies 
(i.e. canyons vs. mountains vs. plains); it's a type of "ruggedness" or "roughness" index.  It is 
calculated as the difference between the value of a cell and the mean value of its 8 surrounding cells.

Here the TPI is automatically calculated using the *raster* package.  
Values are then added to the Wetlands.spdf.
```{r}
RR = raster(nrow = yROW, ncol = xCOL)
extent(RR) = extent(DEM)

DEM2 = resample(DEM, RR, 
                method='bilinear')

tpi = terrain(DEM2, 
              opt = 'tpi')

TPI = reclassify(tpi, 
                 cbind(NA, minValue(tpi)))

proj4string(TPI) = proj4string(LCLU_NWF.spdf)
extent(TPI) = extent(LCLU_NWF.spdf)

Wetlands.spdf$TPI = values(TPI)
```

###Verify Significance of TPI
```{r}
Form6 = Designation ~ TPI

TPImod  =  inla(Form6, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(TPImod)
TPImod$dic$dic
```


Create a Compound Topographic Index (CTI) (aka a "Wetness Index").  

CTI values are scaled such that higher values represent represent drainage depressions (wetter areas),
and lower values represent elevated or drier areas.

CTI = ln(a/tan B)
Where "a" is the upstream contributing area in m2 (Flow Accumulation) and "B" is the slope as measured in (Radians)

This calculation is carried-out using the *dynatopmodel* package.
Resulting values are added to the Wetlands.spdf.
```{r}
suppressMessages(library(dynatopmodel))

CTI0 = upslope.area(DEM, 
                    log = TRUE, 
                    atb = TRUE, 
                    deg = 0.1)

CTI = reclassify(CTI0$atb, 
                 cbind(NA, maxValue(CTI0)))

extent(CTI) = extent(LCLU_NWF.spdf)
CTI = resample(CTI, Blank.r, method = 'bilinear')

Wetlands.spdf$CTI = values(CTI)
```

###Verify Significance of CTI
```{r}
Form7 = Designation ~ CTI

CTImod  =  inla(Form7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(CTImod)
CTImod$dic$dic
```

###Initial Evaluation for Collinearity
Colldiag() is an implementation of the regression collinearity diagnostic procedures found in Belsley, Kuh, and Welsch (1980). These procedures examine the "conditioning" of the matrix of independent variables.

Colldiag() computes the condition indexes of the matrix. If the largest condition index (the condition number) is large (Belsley et al suggest 30 or higher), then there may be collinearity problem.
```{r}
suppressMessages(library(perturb))

Col.df = Wetlands.spdf@data %>%
            select(V1, V2, V3, MCAV3, AWC, OM, SAVI, TPI, CTI) 

CI = colldiag(Col.df)
CI

detach("package:perturb", unload=TRUE)
```


#Bayesian Analysis
Bayesian analysis is conducted to identify the probability of wetland presence using the explanatory variables 
from the PCA, MCA, SAVI, and Topographic Indices.

###Assign Region and IDs Labels
```{r}
Wetlands.spdf$Region = 1:nrow(Wetlands.spdf)
```

###Spatial Neighborhood as an INLA Graph
Define spatial neighborhood.
```{r}
nb = poly2nb(Wetlands.spdf, 
                queen = FALSE)

nb2INLA("J", nb)
J = inla.read.graph("J")

#summary(nb)
```

##Spatial Structure Only
###(Conditional Autoregressive - CAR)
Include structured graph ("J"), specify the "besag" model, and add priors as previously determined.

The "adjust.for.con.comp"" control adjust the graph when it has more than one connected component.

The "scale.model" option specifies that the model should be scaled to have an average
variance equal to 1. See: http://www.math.ntnu.no/inla/r-inla.org/doc/latent/besag.pdf
```{r}
formula0 = Designation ~ f(Region, model = "besag",
                           scale.model = TRUE,
                           adjust.for.con.comp = FALSE, 
                           graph = J) 
                         

model0  =  inla(formula0, family = "binomial",
                control.family = list(link = "cloglog"),
                control.predictor = list(compute = TRUE),
                control.compute = list(cpo = TRUE, waic=TRUE),
                data = Wetlands.spdf@data)

summary(model0)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M0SLPM = model0$summary.linear.predictor[,"mean"],
                               M0Prob = exp(M0SLPM)/(1+exp(M0SLPM)))
```


###Figure 2a (Plot Random Effects)
```{r}
RE.r = Blank.r
Wetlands.spdf$SREm0 = model0$summary.random$Region[,2]
values(RE.r) = (exp(model0$summary.random$Region$mean/12) - 1) * 100
  
REffect = round(Wetlands.spdf$SREm0, 4)
Var = rep("RE", length(REffect))
RE.df = data.frame(Var, REffect)
RE.df$REffect = as.numeric(RE.df$REffect)

RE.d = ggplot(RE.df, aes(REffect, fill = as.factor(Var))) + 
              geom_density(fill = "grey") +
              theme_classic() +
              xlim(-25, 25) +
                 xlab("Primary Domain (model0)") +
                 ylab("Density") +
                 theme(axis.title.y = element_text(size = 15),
                       axis.title.x = element_text(size = 15),
                       plot.title = element_text(size = 20, face="bold")) +
                 geom_vline(data = RE.df, 
                 aes(xintercept = 0,
                     colour = Run),
                     linetype = "dotted",
                     size = 1, col = "red") + 
                ggtitle("Spatial Random Effects")

RE.d 


rng = seq(-100, 250, 35)

rngL = paste(rng, '%', sep = "")
cr = rev(brewer.pal(10, "RdBu"))

M0RE = levelplot(RE.r, margin = FALSE,
          sub = "                Spatial Random Effects (model0)                \n(Above/Below Domain Mean)",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))  

M0RE
```


##Add Explanatory Variables 
###(Spatial Structure + Covariates)
```{r}
formula1 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1

model1  =  inla(formula1, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model1)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M1SLPM = model1$summary.linear.predictor[,"mean"],
                               M1Prob = exp(M1SLPM)/(1+exp(M1SLPM)))
```

##model2
```{r}
formula2 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2

model2  =  inla(formula2, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model2)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M2SLPM = model2$summary.linear.predictor[,"mean"],
                               M2Prob = exp(M2SLPM)/(1+exp(M2SLPM)))
```

##model3
```{r}
formula3 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3

model3  =  inla(formula3, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model3)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M3SLPM = model3$summary.linear.predictor[,"mean"],
                               M3Prob = exp(M3SLPM)/(1+exp(M3SLPM)))
```

##model4
```{r}
formula4 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC

model4  =  inla(formula4, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model4)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M4SLPM = model4$summary.linear.predictor[,"mean"],
                               M4Prob = exp(M4SLPM)/(1+exp(M4SLPM)))
```

##model5
```{r}
formula5 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM

model5  =  inla(formula5, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model5)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M5SLPM = model5$summary.linear.predictor[,"mean"],
                               M5Prob = exp(M5SLPM)/(1+exp(M5SLPM)))
```

##model6
```{r}
formula6 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI

model6  =  inla(formula6, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model6)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M6SLPM = model6$summary.linear.predictor[,"mean"],
                               M6Prob = exp(M6SLPM)/(1+exp(M6SLPM)))
```

##model7
```{r}
D100ST = Sys.time()

formula7 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model7  =  inla(formula7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model7)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M7SLPM = model7$summary.linear.predictor[,"mean"],
                               M7Prob = exp(M7SLPM)/(1+exp(M7SLPM)))

D100ET = Sys.time()
D100Time = as.numeric(D100ET - D100ST, units = "mins")
D100cnt = length(Wetlands.spdf@data$Designation)
```

##model8
```{r}
formula8 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI + SAVI

model8  =  inla(formula8, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model8)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M8SLPM = model8$summary.linear.predictor[,"mean"],
                               M8Prob = exp(M8SLPM)/(1+exp(M8SLPM)))
```

##model9
```{r}
formula9 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                          V1 + V2 + V3 + AWC + CTI + TPI

model9  =  inla(formula9, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model9)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M9SLPM = model9$summary.linear.predictor[,"mean"],
                               M9Prob = exp(M9SLPM)/(1+exp(M9SLPM)))
```

##model10
```{r}
#No Prior
formula10 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model10  =  inla(formula10, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model10)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M10SLPM = model10$summary.linear.predictor[,"mean"],
                               M10Prob = exp(M10SLPM)/(1+exp(M10SLPM)))
```

##model11
```{r}
#Non-spatial
formula11 = Designation ~ V1 + V2 + V3 + AWC + OM + CTI + TPI

model11  =  inla(formula11, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model11)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M11SLPM = model11$summary.linear.predictor[,"mean"],
                               M11Prob = exp(M11SLPM)/(1+exp(M11SLPM)))
```


##Model Selection Tables
Setting-up tables to compare models
```{r}
Models = c("model0", "model1",
           "model2", "model3",
           "model4", "model5",
           "model6","model7",
           "model8", "model9",
           "model10", "model11")

Fixed =  c("u (Spatial structure only) ",
           "V1 + u",
           "V1 + V2 + u",
           "V1 + V2 + V3 + u",
           "V1 + V2 + V3 + AWC + u",
           "V1 + V2 + V3 + AWC + OM + u",
           "V1 + V2 + V3 + AWC + OM + CTI + u",
           "V1 + V2 + V3 + AWC + OM + CTI + TPI + u",
           "V1 + V2 + V3 + AWC + OM + CTI + TPI + SAVI + u",
           "V1 + V2 + V3 + AWC + CTI + TPI + u",
           "(model7 with no prior specification)",
           "(model7 excluding spatial structure)")

#Watanabe-Akaike information criteria
WAICs = c(model0$waic$waic, model1$waic$waic,
          model2$waic$waic, model3$waic$waic,
          model4$waic$waic, model5$waic$waic,
          model6$waic$waic, model7$waic$waic,
          model8$waic$waic, model9$waic$waic,
          model10$waic$waic, model11$waic$waic)

LCPOs = c(-mean(log(model0$cpo$cpo)), -mean(log(model1$cpo$cpo)),
          -mean(log(model2$cpo$cpo)), -mean(log(model3$cpo$cpo)),
          -mean(log(model4$cpo$cpo)), -mean(log(model5$cpo$cpo)),
          -mean(log(model6$cpo$cpo)), -mean(log(model7$cpo$cpo)),
          -mean(log(model8$cpo$cpo)), -mean(log(model8$cpo$cpo)),
          -mean(log(model10$cpo$cpo)), -mean(log(model11$cpo$cpo)))

#Brier score (looking only at Wetlands - not uplands)
BSs.df = filter(Wetlands.spdf@data, Designation == 1)
BSs = c(mean((BSs.df$M0Prob - 1)^2), mean((BSs.df$M1Prob - 1)^2),
        mean((BSs.df$M2Prob - 1)^2), mean((BSs.df$M3Prob - 1)^2),
        mean((BSs.df$M4Prob - 1)^2), mean((BSs.df$M5Prob - 1)^2),
        mean((BSs.df$M6Prob - 1)^2), mean((BSs.df$M7Prob - 1)^2),
        mean((BSs.df$M8Prob - 1)^2), mean((BSs.df$M9Prob - 1)^2),
        mean((BSs.df$M10Prob - 1)^2), mean((BSs.df$M11Prob - 1)^2))

Model_mets = as.data.frame(cbind(MODEL = Models,
                                 WAIC = round(WAICs, 2),
                                 LCPO = round(LCPOs, 3),
                                 BS = round(BSs, 3),
                                 COVARIATES = Fixed))
```


###Function to Exponentiate Model Summary
```{r}
FIX = function(x){
             IM = as.data.frame(x["summary.fixed"])
             expMean = round((exp(IM["summary.fixed.mean"])-1)*100, 2)
             exp0.025 = round((exp(IM["summary.fixed.0.025quant"])-1)*100, 2)
             exp0.975 = round((exp(IM["summary.fixed.0.975quant"])-1)*100, 2)
             IM.rpt = as.data.frame(cbind(expMean, exp0.025, exp0.975=exp0.975))
             rownames(IM.rpt) = rownames(IM)
             colnames(IM.rpt) = c("expMean", "exp0.025", "exp0.975")
             IM.rpt
             }         
```


###Table 1 and Table 2 
Watanabe-Akaike information criterion (WAIC), Log Conditional Predictive Ordinancesand (LCPO), 
and Brier Score (BS) for all model are compared below.
```{r}
print.data.frame(Model_mets, right = FALSE)

print.data.frame(model7$summary.fixed)

#Exponentiate
FIX(model7)

#library(xtable)
#Table2 = xtable(Model_mets)
#print(Table2, include.rownames = FALSE)

#M7.df = as.data.frame(model7$summary.fixed)
#colnames(M7.df) = c("Mean", "sd", "Quant0.025", "Quant0.5", "Quant0.975", "mode", "kld")
#M7b.df = M7.df %>%
#            select(Mean, Quant0.025, Quant0.975)

#Mod7Table = xtable(M7b.df, 
#                   digits=c(0,4,4, 4))
#print(Mod7Table, 
#     include.rownames = TRUE, 
#      floating = TRUE )
```

###Second Evaluation for Collinearity
Check models for possible collinearity
```{r}
suppressMessages(library(perturb))

Col_M8.df = Wetlands.spdf@data %>%
            select(V1, V2, V3, AWC, OM, SAVI, TPI, CTI) 

M8_col = colldiag(Col_M8.df)
M8_col


Col_M7.df = Wetlands.spdf@data %>%
            select(V1, V2, V3, AWC, OM, TPI, CTI) 

M7_col = colldiag(Col_M7.df)
M7_col

detach("package:perturb", unload=TRUE)
```


###ggplotmargin Function
Function for plotting the density of the marginal terms.
```{r}
ggplotmargin <- function(x, type, effect, xlab, ylab = "Posterior Density",
                         int.value = c(value = 0, 5, 95),
                         color = c("red", "gray", "gray")){
xx = as.data.frame(inla.smarginal(x[[paste("marginals", type, sep=".")]][[effect]]))
  out = ggplot(xx, aes(x, y)) + geom_line(size = 1) + ylab(ylab) + xlab(xlab)    
if(length(int.value) == 0) int.value = 0
int.value = lapply(int.value, function(x) if(is.character(x)) 
  type.convert(x, as.is = TRUE) else x)
int.value = lapply(int.value, function(x) if(is.character(x)) 
  lapply(strsplit(x, "=")[[1]], type.convert, as.is = TRUE) else x)
nx = names(int.value)
if(!is.null(nx))
   for(i in which(nx != ""))  int.value[[i]] = list(nx[i], int.value[[i]])
    int.value = sapply(int.value, function(x) {
                      if(is.numeric(x)) xx$x[which.max(cumsum(xx$y)/sum(xx$y) >= as.numeric(x/100))]
                      else switch(x[[1]], 
                      mean = sum(xx$y*xx$x)/sum(xx$y), 
                      median = xx$x[which.max(cumsum(xx$y)/sum(xx$y) >=.5)],
                      mode = xx$x[which.max(xx$y)],
                      value = x[[2]],
                      zero = 0)})

if(length(color) <= length(int.value)) color = rep(color, length = length(int.value))
for(i in 1:length(int.value)) out = out + geom_vline(xintercept = int.value[i], color = color[i]) 
out
}
```


##Density of the Marginal Terms
###(Selected Model)
```{r}
results = model7
results$marginals.fixed$V1[, 1] = (exp(-results$marginals.fixed$V1[, 1]) - 1) * 100
results$marginals.fixed$V2[, 1] = (exp(-results$marginals.fixed$V2[, 1]) - 1) * 100
results$marginals.fixed$TPI[, 1] = (exp(results$marginals.fixed$TPI[, 1]) - 1) * 100
results$marginals.fixed$V3[, 1] = (exp(results$marginals.fixed$V3[, 1]) - 1) * 100
results$marginals.fixed$AWC[, 1] = (exp(results$marginals.fixed$AWC[, 1]) - 1) * 100
results$marginals.fixed$CTI[, 1] = (exp(results$marginals.fixed$CTI[, 1]) - 1) * 100
results$marginals.fixed$OM[, 1] = (exp(results$marginals.fixed$OM[, 1]) - 1) * 100

plotV1 = ggplotmargin(results, type = "fixed", 
                     effect = "V1", xlab = "V1")

plotV2 = ggplotmargin(results, type = "fixed", 
                      effect = "V2", xlab = "V2")

plotV3 = ggplotmargin(results, type = "fixed", 
                       effect = "V3", xlab = "V3")

plotCTI = ggplotmargin(results, type = "fixed",
                       effect = "CTI", xlab = "CTI")

plotTPI = ggplotmargin(results, type = "fixed", 
                       effect = "TPI", xlab = "TPI")

plotAWC = ggplotmargin(results, type = "fixed",
                       effect = "AWC", xlab = "AWC")

plotOM = ggplotmargin(results, type = "fixed",
                       effect = "OM", xlab = "OM")

grid.arrange(plotV1, plotV2, plotV3, plotAWC, plotOM, plotCTI, plotTPI, ncol=3)
```

###Figure 2b (Plot Random Effects)
```{r}
RE1.r = Blank.r
Wetlands.spdf$SREm7 = model7$summary.random$Region[,2]
values(RE1.r) = exp((-model7$summary.random$Region[,2]/12) - 1) * 100


REffect = round(Wetlands.spdf$SREm7, 4)
Var = rep("RE", length(REffect))
RE.df = data.frame(Var, REffect)
RE.df$REffect = as.numeric(RE.df$REffect)

RE.d = ggplot(RE.df, aes(REffect, fill = as.factor(Var))) + 
              geom_density(fill = "grey") +
              theme_classic() +
              xlim(-25, 25) +
                 xlab("Primary Domain (model7)") +
                 ylab("Density") +
                 theme(axis.title.y = element_text(size = 15),
                       axis.title.x = element_text(size = 15),
                       plot.title = element_text(size = 20, face="bold")) +
                 geom_vline(data = RE.df, 
                 aes(xintercept = 0,
                     colour = Run),
                     linetype = "dotted",
                     size = 1, col = "red") + 
                ggtitle("Spatial Random Effects")

RE.d 


rng = seq(-100, 250, 35)

rngL = paste(rng, '%', sep = "")
cr = rev(brewer.pal(10, "RdBu"))

M7RE = levelplot(RE1.r, margin = FALSE,
          sub = "                Spatial Random Effects (model7)                \n(Above/Below Domain Mean)",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))  

M7RE
```


###Wetland Probabilty Map
Plot the Wetland Probability Map
```{r}
M2p = Blank.r
values(M2p) = Wetlands.spdf@data$M7Prob

rng = seq(0, 1, 0.1)
rngL = paste(rng*100, '%', sep = "")
cr = brewer.pal(10, "BrBG")
M2pb = levelplot(M2p, margin = FALSE, 
          sub = "Probabilty of Wetland Presence             ",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))

M2pb
```


```{r}
rm(list=setdiff(ls(), c("FIX", "model7", "SDAquery", "D100Time", "D100cnt")))
```





Change Resolution
==================
The initial project domain encompassed a 100km^2 area and processed raster objects utilizing a cell edge of 50m.  The sensitivity of the model to changes in resolution is explored below by first increasing the resolution to 30m and then coarsening data to a 70m cell edge length.  The selected model ("model7") is applied to both resolutions while holding the domain areal extent constant.

##30m Cell Edge

###Domain Shapefile
```{r}
#Domain (shapefile)
Domain100 = readOGR(dsn = "./WetlandData/Domains/Domain100", layer = "Domain100", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    gIsValid(Domain100)
                    Domain100 = gBuffer(Domain100, width=0, byid=TRUE)
```

###Domain Target Cell Size (TCS)
```{r}
TCS = 30 #Raster cell edge length (meters)

xCOL = ceiling(10000/TCS)
yROW = ceiling(10000/TCS)
```

###Read Soil and Landuse/Landcover Shapefiles
```{r}

#Soils Data
    Raw_Soils.spdf = readOGR(dsn = "./WetlandData/SSURGO_NWF", layer = "SSURGO_NWF", 
                     stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                     Raw_Soils.spdf = crop(Raw_Soils.spdf, Domain100) 
                     gIsValid(Raw_Soils.spdf) #Chk TopologY
                     Raw_Soils.spdf = gBuffer(Raw_Soils.spdf, width=0, byid=TRUE) #Fix Topology
    Raw_Soils.df = Raw_Soils.spdf@data
 

#Landcover/Landuse Data
    LCLU_NWF.spdf = readOGR(dsn = "./WetlandData/LCLU_NWF", layer = "LCLU_NWF", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    LCLU_NWF.spdf = crop(LCLU_NWF.spdf, Domain100) 
                    gIsValid(LCLU_NWF.spdf)
    LCLU_NWF.spdf = gBuffer(LCLU_NWF.spdf, width=0, byid=TRUE)   
```


###Subset Landcover Groups
```{r}    
UP_LC.spdf = subset(LCLU_NWF.spdf, 
                    LANDUSE_CO >= 2600 & 
                    LANDUSE_CO <= 4430 )

Wet_LC.spdf = subset(LCLU_NWF.spdf, 
                     LANDUSE_CO >= 5000 & 
                     LANDUSE_CO <= 6999 )
```


###Crop soils data
```{r}
UP_Soils.spdf = crop(Raw_Soils.spdf, UP_LC.spdf) 
UP_Soils.spdf@data = UP_Soils.spdf@data %>%
                     mutate(Designation = 0)


Wet_Soils.spdf = crop(Raw_Soils.spdf, Wet_LC.spdf)
Wet_Soils.spdf@data = Wet_Soils.spdf@data %>%
                      mutate(Designation = 1)
```

```{r}
UP_Soils1.spdf = spChFIDs(UP_Soils.spdf, 
                          paste(as.character(
                                1:nrow(UP_Soils.spdf)),"U", sep = ""))

Wet_Soils1.spdf = spChFIDs(Wet_Soils.spdf, 
                           paste(as.character(
                                1:nrow(Wet_Soils.spdf)),"W", sep = ""))

Soils.spdf = spRbind(UP_Soils1.spdf, Wet_Soils1.spdf)

Soils.spdf$IDs = 1:nrow(Soils.spdf)
```


###Combine Upland and Wetland Data Frames
```{r}
Soils.df = Soils.spdf@data

Soils0.df = subset(Soils.df, 
                   select = -c(AREASYMBOL,  SPATIALVER, NationalMu,  
                                muhelcl,  muwathelcl,  muwndhelcl,  interpfocu, 
                                invesinten,  lkey,  iacornsr,  projectsca,  tabularver, 
                                iccdcd,   iccdcdpct,  engstafdcd,  engstafll,  engstafml, 
                                albedo_h,  albedo_l,  cropprodin,  rsprod_h,  rsprod_l, 
                                rsprod_r,  slopelen_h,  slopelen_l,  cokey,  comppct_l,   
                                comppct_h,  compkind,  earthcovki,  earthcov_1,  aspectccwi, 
                                aspectrep,  aspectcwis,  geomdesc,  nirrcapuni,  irrcapcl, 
                                irrcapscl,  irrcapunit,  constreesh,  soilslippo,  frostact, 
                                soiltaxedi,  taxclname,  taxorder,  taxsuborde,  taxgrtgrou, 
                                taxsubgrp,  taxparts_1, map_h,  map_l,	map_r, Shape_Leng, Shape_Area))

Soils1.df = as.data.frame(lapply
                          (Soils0.df, factor))
Soils2.df = Soils1.df %>%
            mutate(Designation = as.numeric(Soils.df$Designation),
                   IDs = as.numeric(Soils.df$IDs),
                   wtdepaprju = as.numeric(round(Soils.df$wtdepaprju),5),
                   wtdepannmi = as.numeric(round(Soils.df$wtdepannmi),5),
                   slopegradd = as.numeric(round(Soils.df$slopegradd),5),
                   slopegradw = as.numeric(round(Soils.df$slopegradw), 5),
                   aws025wta = as.numeric(round(Soils.df$aws025wta), 5),
                   aws050wta = as.numeric(round(Soils.df$aws050wta), 5),
                   aws0100wta = as.numeric(round(Soils.df$aws0100wta), 5),
                   aws0150wta = as.numeric(round(Soils.df$aws0150wta), 5),
                   niccdcdpct = as.numeric(round(Soils.df$niccdcdpct), 5),
                   albedo_r = as.numeric(round(Soils.df$albedo_r), 5),
                   elev_h = as.numeric(round(Soils.df$elev_h), 5),
                   elev_l = as.numeric(round(Soils.df$elev_l), 5),
                   elev_r = as.numeric(round(Soils.df$elev_r), 5),
                   slope_h = as.numeric(round(Soils.df$slope_h), 5),
                   slope_r = as.numeric(round(Soils.df$niccdcdpct), 5))
```

###Prior Distribution
```{r}
D0 = 0.33 #Prob of wetlands in Florida
D1 = 0.50 #Prop of being wetland if known to have wetland vegetation

Soils.spdf$Extent = gArea(Soils.spdf,
                          byid = TRUE)

Wet_area = as.numeric(
             Soils.spdf@data %>%
                       filter(Designation == 1) %>%
                       summarise(sum(Extent, na.rm = TRUE)))

Up_area = as.numeric(
            Soils.spdf@data %>%
                      filter(Designation == 0) %>%
                      summarise(sum(Extent, na.rm = TRUE)))

Wp = (Wet_area/(Wet_area + Up_area))
Up = (Up_area/(Wet_area + Up_area))

Pr = (Up*D0) + (Wp*D1)

q1 = list(p = .5, x = Pr)
q2 = list(p = .9, x = D1)
B.select = beta.select(q1, q2) 

a = B.select[1]
b = B.select[2]

hyper.p = list(prec = list(
                        list(prior = "logitbeta", 
                             param = c(a, b),
                             initial = 0)))
```

###Conduct Principal Components Analysis (PCA)
``` {r}
Soils.PCA = Soils2.df %>%
                select(slopegradd, slopegradw, aws025wta, aws050wta, aws0100wta,
                aws0150wta, niccdcdpct, albedo_r, elev_h, elev_l, elev_r, slope_h, 
                slope_r, wtdepaprju, wtdepannmi)

PCA.Result = PCA(Soils.PCA , 
                 scale.unit = TRUE, 
                 ncp = 5, 
                 graph = FALSE)
```

###Singular Value Decomposition (SVD) to Data Frame
```{r}
PCA.df = as.data.frame(PCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```

###Conduct Multiple Correspondance Analysis (MCA)
``` {r}
Soils.MCA = Soils2.df %>%
               select(MUSYM, muname, mukind, farmlndcl, museq, brockdepmi, 
                      flodfreqdc, flodfreqma, pondfreqpr, drclassdcd, 
                      drclasswet, hydgrpdcd, niccdcd, engdwobdcd, engdwbdcd,  engdwbll,  
                      engdwbml,   engsldcd,   engsldcp, englrsdcd,  engcmssdcd, engcmssmp, 
                      urbrecptdc, urbrecptwt, forpehrtdc, hydclprs, awmmfpwwta, airtempa_h, 
                      airtempa_l, airtempa_r, ffd_h, ffd_l, ffd_r, initsub_h, initsub_l, 
                      initsub_r, slope_l, slopelen_r, totalsub_h, totalsub_l, totalsub_r, 
                      compname, otherph, localphase, runoff, tfact, wei, weg, erocl, 
                      hydricon, nirrcapcl, nirrcapscl, foragesuit, wlgrai, wlgrass, wlherbaceo,
                      wlshrub, wlconifero, wlhardwood, wlwetplant, wlshalloww, wlrangelan, 
                      wlopenland, wlwoodland, wlwetland, corcon, corsteel, taxpartsiz, 
                      taxceactcl, taxreactio, taxtempcl, taxmoistsc, taxtempreg)

MCA.Result = MCA(Soils.MCA, 
                 ncp=5, 
                 graph = FALSE)
```

###MCA Singular Value Decomposition (SVD) to .df
```{r}
MCA.df = as.data.frame(MCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```


###Combine Significant MCA and PCA Results
Attach the significant MCA and PCA results to Soils2.spdf.

Also added is the "MUKEY" column from the Soils.spdf that will be used to explore additional soils data later.
```{r}
Soils2.spdf = Soils.spdf

Soils2.spdf@data = PCA.df %>%
                   select(Designation, V1, V2, V3) %>%
                   mutate(MCA3 = MCA.df[,"V3"],
                          MUKEY = as.numeric(Soils.spdf@data[,"MUKEY"]))
```


###Convert Soils PCA and MCA Results to Raster Objects
First, create a raster template based on the resolution specified at top of the script.
```{r}
Blank.r = raster(nrows = yROW, ncols = xCOL)
extent(Blank.r) = extent(Soils2.spdf)
proj4string(Blank.r) = proj4string(Soils2.spdf)
```


###Create Wetland/Upland Designation Raster
```{r}
w_rast = rasterize(Wet_Soils.spdf,
                   Blank.r,
                   field = 1)

w_rast = reclassify(w_rast,
                    cbind(NA, 0))
```


###Create Rasters for Significatnt PCA/MCA Results
```{r}
V1_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V1)

V2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V2)

V3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V3)

MCA3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$MCA3)
```


###Convert Rasters to SpatialPolygonsDataFrame
Add PCA and MCA results
```{r}
Wetlands.spdf = as(w_rast, "SpatialPolygonsDataFrame")
names(Wetlands.spdf) = "Designation"

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(V1 = values(V1_rast),
                               V2 = values(V2_rast),
                               V3 = values(V3_rast),
                               MCAV3 = values(MCA3_rast))
```

##AWC and OM
###Rasterize MUKEY 
```{r}
AWC.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)

OM.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)
```

###Soil Functions
```{r}
HzWS = function(i) {
              wt = i$comppct_r[1]  
              thick = with(i, hzdepb_r - hzdept_r)  
              whc = thick * i$awc_r 
            	whc.total = sum(whc, na.rm=TRUE)  
	            data.frame(whc = whc.total, wt=wt)  
}

HzWSO = function(i) {
              wto = i$comppct_r[1]  
              thicko = with(i, hzdepb_r - hzdept_r)  
              whco = thicko * i$Om_r  
            	whc.totalo = sum(whco, na.rm=TRUE)   
	            data.frame(whco = whc.totalo, wto=wto)  
}
```

The next two functions find the average (weighted by component percentage) within each Soil Map Unit
```{r}
MU_mean = function(i) {
	              whc = wtd.mean(i$whc, weights=i$wt)  
	              data.frame(whc=whc)  
}

MU_meano = function(i) {
	              whco = wtd.mean(i$whco, weights=i$wto)  
	              data.frame(whco=whco)  
}
```

###Add Raster Attribute Table (RAT)
```{r}
AWC.r = ratify(AWC.r,
               count = TRUE)

OM.r = ratify(OM.r,
               count = TRUE)
```

###save RATs as Objects
```{r}
rat = levels(AWC.r)[[1]]

rato = levels(OM.r)[[1]]
```

###Extract MUKEYs from the RAT
```{r}
in.statement = format_SQL_in_statement(rat$ID)

in.statement2 = format_SQL_in_statement(rato$ID)
```


###Query SDA
```{r}
q = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

ACW.res = SDAquery(q) 
```

```{r}
q2 = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

OM.res = SDAquery(q2) 
```

###Aggregate Data
```{r}
co.whc = ACW.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWS(.))

mu.whc = co.whc %>% 
              group_by(mukey) %>% 
              do(MU_mean(.))

co.whco = OM.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWSO(.))

mu.whco = co.whco %>% 
              group_by(mukey) %>% 
              do(MU_meano(.))
```

###Join Results to Domain Rasters
```{r}
names(mu.whc)[1] = 'ID'
rat.new = left_join(rat, mu.whc)
levels(AWC.r) = rat.new
AWC = deratify(AWC.r, att='whc')

names(mu.whco)[1] = 'ID'
rato.new = left_join(rato, mu.whco)
levels(OM.r) = rato.new
OM = deratify(OM.r, att='whco')
```

###Add Results to Wetlands.spdf
```{r}
Wetlands.spdf$AWC = values(AWC)
Wetlands.spdf$OM = values(OM)
```


###Explanatory Variables linked to Topograpy
```{r}
#DEM (USGS 1/3 arc-sec)
      DEM = raster("./WetlandData/DEM_NWF/dem_nwf/w001001.adf")
      DEM = reclassify(DEM, 
                        cbind(0, 0.001))
      
      DomainB = readOGR(dsn = "./WetlandData/Domains/Domain100", layer = "Domain100", 
                    stringsAsFactors = FALSE)
      
            DomainBp = spTransform(DomainB, 
                       CRS(projection(DEM)))
      
      DEM = crop(DEM, DomainBp)
```


###Calculate Topographic Indicies
```{r}
RR = raster(nrow = yROW, ncol = xCOL)
extent(RR) = extent(DEM)

DEM2 = resample(DEM, RR, 
                method='bilinear')

tpi = terrain(DEM2, 
              opt = 'tpi')

TPI = reclassify(tpi, 
                 cbind(NA, minValue(tpi)))

proj4string(TPI) = proj4string(LCLU_NWF.spdf)
extent(TPI) = extent(LCLU_NWF.spdf)

Wetlands.spdf$TPI = values(TPI)
```

```{r}
CTI0 = upslope.area(DEM, 
                    log = TRUE, 
                    atb = TRUE, 
                    deg = 0.1)

CTI = reclassify(CTI0$atb, 
                 cbind(NA, maxValue(CTI0)))

extent(CTI) = extent(LCLU_NWF.spdf)
CTI = resample(CTI, Blank.r, method = 'bilinear')

Wetlands.spdf$CTI = values(CTI)
```


#Bayesian Analysis
###Assign Region and IDs Labels
```{r}
Wetlands.spdf$Region = 1:nrow(Wetlands.spdf)
```

###Spatial Neighborhood as an INLA Graph
```{r}
nb = poly2nb(Wetlands.spdf, queen = FALSE)
nb2INLA("J", nb)
J = inla.read.graph("J")
```

###Run Selected Model
```{r}
D30ST = Sys.time()

formula7 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model7_30  =  inla(formula7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model7_30)

#Exponentiate
FIX(model7_30)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M730SLPM = model7_30$summary.linear.predictor[,"mean"],
                               M730Prob = exp(M730SLPM)/(1+exp(M730SLPM)))

D30ET = Sys.time()
D30Time = as.numeric(D30ET - D30ST, units = "mins")
D30cnt = length(Wetlands.spdf@data$Designation)
```

###Wetland Probabilty Map
```{r}
M2p = Blank.r
values(M2p) = Wetlands.spdf@data$M730Prob

rng = seq(0, 1, 0.10)
rngL = paste(rng*100, '%', sep = "")
cr = brewer.pal(10, "BrBG")
M2pb = levelplot(M2p, margin = FALSE, 
          sub = "Probabilty of Wetland Presence             ",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))

M2pb
```

```{r}
rm(list=setdiff(ls(), c("FIX", "model7", "model7_30", "Domain100", "Soils2.spdf", "Wet_Soils.spdf", 
                        "hyper.p", "SDAquery", "D30Time", "D100Time", "D30cnt", "D100cnt")))
```


#70m Cell Edge
###Domain Target Cell Size (TCS)
```{r}
TCS = 70 #Raster cell edge length (meters)

xCOL = ceiling(10000/TCS)
yROW = ceiling(10000/TCS)
```

###Convert Soils PCA and MCA Results to Raster Objects
First, create a raster template based on the resolution specified at top of the script.
```{r}
Blank.r = raster(nrows = yROW, ncols = xCOL)
extent(Blank.r) = extent(Soils2.spdf)
proj4string(Blank.r) = proj4string(Soils2.spdf)
```


###Create Wetland/Upland Designation Raster
```{r}
w_rast = rasterize(Wet_Soils.spdf,
                   Blank.r,
                   field = 1)

w_rast = reclassify(w_rast,
                    cbind(NA, 0))
```


###Create Rasters for Significatnt PCA/MCA Results
```{r}
V1_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V1)

V2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V2)

V3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V3)

MCA3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$MCA3)
```


###Convert Rasters to SpatialPolygonsDataFrame
```{r}
Wetlands.spdf = as(w_rast, "SpatialPolygonsDataFrame")
names(Wetlands.spdf) = "Designation"

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(V1 = values(V1_rast),
                               V2 = values(V2_rast),
                               V3 = values(V3_rast),
                               MCAV3 = values(MCA3_rast))
```

###Rasterize MUKEY 
```{r}
AWC.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)

OM.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)
```

###Soil Functions
```{r}
HzWS = function(i) {
              wt = i$comppct_r[1]  
              thick = with(i, hzdepb_r - hzdept_r)  
              whc = thick * i$awc_r 
            	whc.total = sum(whc, na.rm=TRUE)  
	            data.frame(whc = whc.total, wt=wt)  
}

HzWSO = function(i) {
              wto = i$comppct_r[1]  
              thicko = with(i, hzdepb_r - hzdept_r)  
              whco = thicko * i$Om_r  
            	whc.totalo = sum(whco, na.rm=TRUE)   
	            data.frame(whco = whc.totalo, wto=wto)  
}
```

The next two functions find the average (weighted by component percentage) within each Soil Map Unit
```{r}
MU_mean = function(i) {
	              whc = wtd.mean(i$whc, weights=i$wt)  
	              data.frame(whc=whc)  
}

MU_meano = function(i) {
	              whco = wtd.mean(i$whco, weights=i$wto)  
	              data.frame(whco=whco)  
}
```

###Add Raster Attribute Table (RAT)
```{r}
AWC.r = ratify(AWC.r,
               count = TRUE)

OM.r = ratify(OM.r,
               count = TRUE)
```

###save RATs as Objects
```{r}
rat = levels(AWC.r)[[1]]

rato = levels(OM.r)[[1]]
```

###Extract MUKEYs from the RAT
```{r}
in.statement = format_SQL_in_statement(rat$ID)

in.statement2 = format_SQL_in_statement(rato$ID)
```


###Query SDA
```{r}
q = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

ACW.res = SDAquery(q) 
```

```{r}
q2 = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

OM.res = SDAquery(q2) 
```

###Aggregate Data
```{r}
co.whc = ACW.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWS(.))

mu.whc = co.whc %>% 
              group_by(mukey) %>% 
              do(MU_mean(.))

co.whco = OM.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWSO(.))

mu.whco = co.whco %>% 
              group_by(mukey) %>% 
              do(MU_meano(.))
```

###Join Results to Domain Rasters
```{r}
names(mu.whc)[1] = 'ID'
rat.new = left_join(rat, mu.whc)
levels(AWC.r) = rat.new
AWC = deratify(AWC.r, att='whc')

names(mu.whco)[1] = 'ID'
rato.new = left_join(rato, mu.whco)
levels(OM.r) = rato.new
OM = deratify(OM.r, att='whco')
```

###Add Results to Wetlands.spdf
```{r}
Wetlands.spdf$AWC = values(AWC)
Wetlands.spdf$OM = values(OM)
```


###Explanatory Variables linked to Topograpy
```{r}
#DEM (USGS 1/3 arc-sec)
      DEM = raster("./WetlandData/DEM_NWF/dem_nwf/w001001.adf")
      DEM = reclassify(DEM, 
                        cbind(0, 0.001))
      
       DomainB = readOGR(dsn = "./WetlandData/Domains/Domain100", layer = "Domain100", 
                    stringsAsFactors = FALSE)
      
                 DomainBp = spTransform(DomainB, 
                       CRS(projection(DEM)))
      
      DEM = crop(DEM, DomainBp)
```


###Calculate Topographic Indicies
```{r}
RR = raster(nrow = yROW, ncol = xCOL)
extent(RR) = extent(DEM)

DEM2 = resample(DEM, RR, 
                method='bilinear')

tpi = terrain(DEM2, 
              opt = 'tpi')

TPI = reclassify(tpi, 
                 cbind(NA, minValue(tpi)))

proj4string(TPI) = proj4string(Soils2.spdf)
extent(TPI) = extent(Soils2.spdf)

Wetlands.spdf$TPI = values(TPI)
```

```{r}
CTI0 = upslope.area(DEM, 
                    log = TRUE, 
                    atb = TRUE, 
                    deg = 0.1)

CTI = reclassify(CTI0$atb, 
                 cbind(NA, maxValue(CTI0)))

extent(CTI) = extent(Soils2.spdf)
CTI = resample(CTI, Blank.r, method = 'bilinear')

Wetlands.spdf$CTI = values(CTI)
```

#Bayesian Analysis
###Assign Region and IDs Labels
```{r}
Wetlands.spdf$Region = 1:nrow(Wetlands.spdf)
```

###Spatial Neighborhood as an INLA Graph
```{r}
nb = poly2nb(Wetlands.spdf, queen = FALSE)
nb2INLA("J", nb)
J = inla.read.graph("J")
```

###Run Selected Model
```{r}
D70ST = Sys.time()

formula7 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model7_70  =  inla(formula7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model7_70)

#Exponentiate
FIX(model7_70)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M770SLPM = model7_70$summary.linear.predictor[,"mean"],
                               M770Prob = exp(M770SLPM)/(1+exp(M770SLPM)))

D70ET = Sys.time()
D70Time = as.numeric(D70ET - D70ST, units = "mins")
D70cnt = length(Wetlands.spdf@data$Designation)
```

###Wetland Probabilty Map
```{r}
M2p = Blank.r
values(M2p) = Wetlands.spdf@data$M770Prob

rng = seq(0, 1, 0.10)
rngL = paste(rng*100, '%', sep = "")
cr = brewer.pal(10, "BrBG")
M2pb = levelplot(M2p, margin = FALSE, 
          sub = "Probabilty of Wetland Presence             ",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))

M2pb
```

```{r}
rm(list=setdiff(ls(), c("model7", "model7_30", "model7_70", "SDAquery", "D100Time", "D100cnt", 
                        "D30cnt", "D30Time", "D70Time", "D70cnt", "FIX")))
```




Change Domain Extent
=======================
The initial project domain encompassed a 100km^2 area.  The sensitivity of the model to changes in areal extent is explored below by first increasing the domain to 200km^2 and then to 300km^2.  The selected model ("model7") is applied to both domains holding resolution constant for both with a cell edge of 50m.

###Read Domain200
```{r}
#Domain (shapefile)
Domain200 = readOGR(dsn = "./WetlandData/Domains/Domain200", layer = "Domain200", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    gIsValid(Domain200)
                    Domain200 = gBuffer(Domain200, width=0, byid=TRUE)
```

###Domain Target Cell Size (TCS)
```{r}
TCS = 50 #Raster cell edge length (meters)

xCOL = ceiling(14142/TCS)
yROW = ceiling(14144/TCS)
```

###Read Soil and Landuse/Landcover Shapefiles
```{r}
#Soils Data
    Raw_Soils.spdf = readOGR(dsn = "./WetlandData/SSURGO_NWF", layer = "SSURGO_NWF", 
                     stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                     Raw_Soils.spdf = crop(Raw_Soils.spdf, Domain200) 
                     gIsValid(Raw_Soils.spdf) #Chk TopologY
                     Raw_Soils.spdf = gBuffer(Raw_Soils.spdf, width=0, byid=TRUE) #Fix Topology

#Landcover/Landuse Data
    LCLU_NWF.spdf = readOGR(dsn = "./WetlandData/LCLU_NWF", layer = "LCLU_NWF", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    LCLU_NWF.spdf = crop(LCLU_NWF.spdf, Domain200) 
                    gIsValid(LCLU_NWF.spdf)
                    LCLU_NWF.spdf = gBuffer(LCLU_NWF.spdf, width=0, byid=TRUE)   
```

###Subset Landcover Groups
```{r}    
UP_LC.spdf = subset(LCLU_NWF.spdf, 
                    LANDUSE_CO >= 2600 & 
                    LANDUSE_CO <= 4430 )

Wet_LC.spdf = subset(LCLU_NWF.spdf, 
                     LANDUSE_CO >= 5000 & 
                     LANDUSE_CO <= 6999 )
```

###Crop soils data
```{r}
UP_Soils.spdf = crop(Raw_Soils.spdf, UP_LC.spdf) 
UP_Soils.spdf@data = UP_Soils.spdf@data %>%
                     mutate(Designation = 0)


Wet_Soils.spdf = crop(Raw_Soils.spdf, Wet_LC.spdf)
Wet_Soils.spdf@data = Wet_Soils.spdf@data %>%
                      mutate(Designation = 1)
```

```{r}
UP_Soils1.spdf = spChFIDs(UP_Soils.spdf, 
                          paste(as.character(
                                1:nrow(UP_Soils.spdf)),"U", sep = ""))

Wet_Soils1.spdf = spChFIDs(Wet_Soils.spdf, 
                           paste(as.character(
                                1:nrow(Wet_Soils.spdf)),"W", sep = ""))

Soils.spdf = spRbind(UP_Soils1.spdf, Wet_Soils1.spdf)

Soils.spdf$IDs = 1:nrow(Soils.spdf)
```

###Combine Upland and Wetland Data Frames
```{r}
Soils.df = Soils.spdf@data

Soils0.df = subset(Soils.df, 
                   select = -c(AREASYMBOL,  SPATIALVER, NationalMu,  
                                muhelcl,  muwathelcl,  muwndhelcl,  interpfocu, 
                                invesinten,  lkey,  iacornsr,  projectsca,  tabularver, 
                                iccdcd,   iccdcdpct,  engstafdcd,  engstafll,  engstafml, 
                                albedo_h,  albedo_l,  cropprodin,  rsprod_h,  rsprod_l, 
                                rsprod_r,  slopelen_h,  slopelen_l,  cokey,  comppct_l,   
                                comppct_h,  compkind,  earthcovki,  earthcov_1,  aspectccwi, 
                                aspectrep,  aspectcwis,  geomdesc,  nirrcapuni,  irrcapcl, 
                                irrcapscl,  irrcapunit,  constreesh,  soilslippo,  frostact, 
                                soiltaxedi,  taxclname,  taxorder,  taxsuborde,  taxgrtgrou, 
                                taxsubgrp,  taxparts_1, map_h,  map_l,	map_r, Shape_Leng, Shape_Area))

Soils1.df = as.data.frame(lapply
                          (Soils0.df, factor))
Soils2.df = Soils1.df %>%
            mutate(Designation = as.numeric(Soils.df$Designation),
                   IDs = as.numeric(Soils.df$IDs),
                   wtdepaprju = as.numeric(round(Soils.df$wtdepaprju),5),
                   wtdepannmi = as.numeric(round(Soils.df$wtdepannmi),5),
                   slopegradd = as.numeric(round(Soils.df$slopegradd),5),
                   slopegradw = as.numeric(round(Soils.df$slopegradw), 5),
                   aws025wta = as.numeric(round(Soils.df$aws025wta), 5),
                   aws050wta = as.numeric(round(Soils.df$aws050wta), 5),
                   aws0100wta = as.numeric(round(Soils.df$aws0100wta), 5),
                   aws0150wta = as.numeric(round(Soils.df$aws0150wta), 5),
                   niccdcdpct = as.numeric(round(Soils.df$niccdcdpct), 5),
                   albedo_r = as.numeric(round(Soils.df$albedo_r), 5),
                   elev_h = as.numeric(round(Soils.df$elev_h), 5),
                   elev_l = as.numeric(round(Soils.df$elev_l), 5),
                   elev_r = as.numeric(round(Soils.df$elev_r), 5),
                   slope_h = as.numeric(round(Soils.df$slope_h), 5),
                   slope_r = as.numeric(round(Soils.df$niccdcdpct), 5))
```

###Prior Distribution
```{r}
D0 = 0.33 #Prob of wetlands in Florida
D1 = 0.50 #Prop of being wetland if known to have wetland vegetation

Soils.spdf$Extent = gArea(Soils.spdf,
                          byid = TRUE)

Wet_area = as.numeric(
             Soils.spdf@data %>%
                       filter(Designation == 1) %>%
                       summarise(sum(Extent, na.rm = TRUE)))

Up_area = as.numeric(
            Soils.spdf@data %>%
                      filter(Designation == 0) %>%
                      summarise(sum(Extent, na.rm = TRUE)))

Wp = (Wet_area/(Wet_area + Up_area))
Up = (Up_area/(Wet_area + Up_area))

Pr = (Up*D0) + (Wp*D1)

q1 = list(p = .5, x = Pr)
q2 = list(p = .9, x = D1)
B.select = beta.select(q1, q2) 

a = B.select[1]
b = B.select[2]

hyper.p = list(prec = list(
                        list(prior = "logitbeta", 
                             param = c(a, b),
                             initial = 0)))
```

###Conduct Principal Components Analysis (PCA)
``` {r}
Soils.PCA = Soils2.df %>%
                select(slopegradd, slopegradw, aws025wta, aws050wta, aws0100wta,
                aws0150wta, niccdcdpct, albedo_r, elev_h, elev_l, elev_r, slope_h, 
                slope_r, wtdepaprju, wtdepannmi)

PCA.Result = PCA(Soils.PCA , 
                 scale.unit = TRUE, 
                 ncp = 5, 
                 graph = FALSE)
```

###Singular Value Decomposition (SVD) to Data Frame
```{r}
PCA.df = as.data.frame(PCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```

###Conduct Multiple Correspondance Analysis (MCA)
``` {r}
Soils.MCA = Soils2.df %>%
               select(MUSYM, muname, mukind, farmlndcl, museq, brockdepmi, 
                      flodfreqdc, flodfreqma, pondfreqpr, drclassdcd, 
                      drclasswet, hydgrpdcd, niccdcd, engdwobdcd, engdwbdcd,  engdwbll,  
                      engdwbml,   engsldcd,   engsldcp, englrsdcd,  engcmssdcd, engcmssmp, 
                      urbrecptdc, urbrecptwt, forpehrtdc, hydclprs, awmmfpwwta, airtempa_h, 
                      airtempa_l, airtempa_r, ffd_h, ffd_l, ffd_r, initsub_h, initsub_l, 
                      initsub_r, slope_l, slopelen_r, totalsub_h, totalsub_l, totalsub_r, 
                      compname, otherph, localphase, runoff, tfact, wei, weg, erocl, 
                      hydricon, nirrcapcl, nirrcapscl, foragesuit, wlgrai, wlgrass, wlherbaceo,
                      wlshrub, wlconifero, wlhardwood, wlwetplant, wlshalloww, wlrangelan, 
                      wlopenland, wlwoodland, wlwetland, corcon, corsteel, taxpartsiz, 
                      taxceactcl, taxreactio, taxtempcl, taxmoistsc, taxtempreg)

MCA.Result = MCA(Soils.MCA, 
                 ncp=5, 
                 graph = FALSE)
```

###MCA Singular Value Decomposition (SVD) to .df
```{r}
MCA.df = as.data.frame(MCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```

###Combine Significant MCA and PCA Results
```{r}
Soils2.spdf = Soils.spdf

Soils2.spdf@data = PCA.df %>%
                   select(Designation, V1, V2, V3) %>%
                   mutate(MCA3 = MCA.df[,"V3"],
                          MUKEY = as.numeric(Soils.spdf@data[,"MUKEY"]))
```

###Convert Soils PCA and MCA Results to Raster Objects
```{r}
Blank.r = raster(nrows = yROW, ncols = xCOL)
extent(Blank.r) = extent(Raw_Soils.spdf)
proj4string(Blank.r) = proj4string(Raw_Soils.spdf)
```

###Create Wetland/Upland Designation Raster
```{r}
w_rast = rasterize(Wet_Soils.spdf,
                   Blank.r,
                   field = 1)

w_rast = reclassify(w_rast,
                    cbind(NA, 0))
```

###Create Rasters for Significatnt PCA/MCA Results
```{r}
V1_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V1)

V2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V2)

V3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V3)

MCA3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$MCA3)
```

###Convert Rasters to SpatialPolygonsDataFrame
```{r}
Wetlands.spdf = as(w_rast, "SpatialPolygonsDataFrame")
names(Wetlands.spdf) = "Designation"

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(V1 = values(V1_rast),
                               V2 = values(V2_rast),
                               V3 = values(V3_rast),
                               MCAV3 = values(MCA3_rast))
```

##Soil Available Water Capacity (AWC) and Organic Mass (OM)
###Rasterize MUKEY 
```{r}
AWC.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)

OM.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)
```

###Soil Functions
```{r}
HzWS = function(i) {
              wt = i$comppct_r[1]  
              thick = with(i, hzdepb_r - hzdept_r)  
              whc = thick * i$awc_r 
            	whc.total = sum(whc, na.rm=TRUE)  
	            data.frame(whc = whc.total, wt=wt)  
}

HzWSO = function(i) {
              wto = i$comppct_r[1]  
              thicko = with(i, hzdepb_r - hzdept_r)  
              whco = thicko * i$Om_r  
            	whc.totalo = sum(whco, na.rm=TRUE)   
	            data.frame(whco = whc.totalo, wto=wto)  
}
```

The next two functions find the average (weighted by component percentage) within each Soil Map Unit
```{r}
MU_mean = function(i) {
	              whc = wtd.mean(i$whc, weights=i$wt)  
	              data.frame(whc=whc)  
}

MU_meano = function(i) {
	              whco = wtd.mean(i$whco, weights=i$wto)  
	              data.frame(whco=whco)  
}
```

###Add Raster Attribute Table (RAT)
```{r}
AWC.r = ratify(AWC.r,
               count = TRUE)

OM.r = ratify(OM.r,
               count = TRUE)
```

###save RATs as Objects
```{r}
rat = levels(AWC.r)[[1]]

rato = levels(OM.r)[[1]]
```

###Extract MUKEYs from the RAT
```{r}
in.statement = format_SQL_in_statement(rat$ID)

in.statement2 = format_SQL_in_statement(rato$ID)
```

###Query SDA
```{r}
q = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

ACW.res = SDAquery(q) 
```

```{r}
q2 = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

OM.res = SDAquery(q2) 
```

###Aggregate Data
```{r}
co.whc = ACW.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWS(.))

mu.whc = co.whc %>% 
              group_by(mukey) %>% 
              do(MU_mean(.))

co.whco = OM.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWSO(.))

mu.whco = co.whco %>% 
              group_by(mukey) %>% 
              do(MU_meano(.))
```

###Join Results to Domain Rasters
```{r}
names(mu.whc)[1] = 'ID'
rat.new = left_join(rat, mu.whc)
levels(AWC.r) = rat.new
AWC = deratify(AWC.r, att='whc')

names(mu.whco)[1] = 'ID'
rato.new = left_join(rato, mu.whco)
levels(OM.r) = rato.new
OM = deratify(OM.r, att='whco')
```

###Add Results to Wetlands.spdf
```{r}
Wetlands.spdf$AWC = values(AWC)
Wetlands.spdf$OM = values(OM)
```

###Explanatory Variables linked to Topograpy
```{r}
#DEM (USGS 1/3 arc-sec)
      DEM = raster("./WetlandData/DEM_NWF/dem_nwf/w001001.adf")
      DEM = reclassify(DEM, 
                        cbind(0, 0.001))
      
      DomainB = readOGR(dsn = "./WetlandData/Domains/Domain200", layer = "Domain200", 
                    stringsAsFactors = FALSE)
      
      DomainBp = spTransform(DomainB, 
                       CRS(projection(DEM)))
      
      DEM = crop(DEM, DomainBp)
```

###Calculate Topographic Indicies
```{r}
RR = raster(nrow = yROW, ncol = xCOL)
extent(RR) = extent(DEM)

DEM2 = resample(DEM, RR, 
                method='bilinear')

tpi = terrain(DEM2, 
              opt = 'tpi')

TPI = reclassify(tpi, 
                 cbind(NA, minValue(tpi)))

proj4string(TPI) = proj4string(LCLU_NWF.spdf)
extent(TPI) = extent(LCLU_NWF.spdf)

Wetlands.spdf$TPI = values(TPI)
```

```{r}
CTI0 = upslope.area(DEM, 
                    log = TRUE, 
                    atb = TRUE, 
                    deg = 0.1)

CTI = reclassify(CTI0$atb, 
                 cbind(NA, maxValue(CTI0)))

extent(CTI) = extent(LCLU_NWF.spdf)
CTI = resample(CTI, Blank.r, method = 'bilinear')

Wetlands.spdf$CTI = values(CTI)
```

##Bayesian Analysis
###Assign Region and IDs Labels
```{r}
Wetlands.spdf$Region = 1:nrow(Wetlands.spdf)
```

###Spatial Neighborhood as an INLA Graph
```{r}
nb = poly2nb(Wetlands.spdf, queen = FALSE)
nb2INLA("J", nb)
J = inla.read.graph("J")
```

###Run Previously Fitted Model
```{r}
D200ST = Sys.time()

formula7 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model7_200  =  inla(formula7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model7_200)

#Exponentiate
FIX(model7_200)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M7bSLPM = model7_200$summary.linear.predictor[,"mean"],
                               M7bProb = exp(M7bSLPM)/(1+exp(M7bSLPM)))

D200ET = Sys.time()
D200Time = as.numeric(D200ET - D200ST, units = "mins")
D200cnt = length(Wetlands.spdf@data$Designation)
```

###Wetland Probabilty Map
```{r}
M2p = Blank.r
values(M2p) = Wetlands.spdf@data$M7bProb

rng = seq(0, 1, 0.10)
rngL = paste(rng*100, '%', sep = "")
cr = brewer.pal(10, "BrBG")
M2pb = levelplot(M2p, margin = FALSE, 
          sub = "Probabilty of Wetland Presence             ",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))

M2pb
```

```{r}
rm(list=setdiff(ls(), c("model7", "model7_30", "model7_70", "model7_200", "TCS", "SDAquery",
                        "D100Time", "D30Time", "D70Time", "D200Time", "D200cnt", "D100cnt", "D70cnt",
                        "D30cnt", "FIX")))
```




#Extend Domain to 300km^2
###Domain Target Cell Size (TCS)
```{r}
xCOL = ceiling(17321/TCS)
yROW = ceiling(17328/TCS)
```

###Read Domain, Soil, and Landuse/Landcover Shapefiles
```{r}
#Domain (shapefile)
    Domain300 = readOGR(dsn = "./WetlandData/Domains/Domain300", layer = "Domain300", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    gIsValid(Domain300)
                    Domain300 = gBuffer(Domain300, width=0, byid=TRUE)

#Soils Data
    Raw_Soils.spdf = readOGR(dsn = "./WetlandData/SSURGO_NWF", layer = "SSURGO_NWF", 
                     stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                     Raw_Soils.spdf = crop(Raw_Soils.spdf, Domain300) 
                     gIsValid(Raw_Soils.spdf) #Chk TopologY
                     Raw_Soils.spdf = gBuffer(Raw_Soils.spdf, width=0, byid=TRUE) #Fix Topology

#Landcover/Landuse Data
    LCLU_NWF.spdf = readOGR(dsn = "./WetlandData/LCLU_NWF", layer = "LCLU_NWF", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    LCLU_NWF.spdf = crop(LCLU_NWF.spdf, Domain300) 
                    gIsValid(LCLU_NWF.spdf)
                    LCLU_NWF.spdf = gBuffer(LCLU_NWF.spdf, width=0, byid=TRUE)   
```

###Subset Landcover Groups
```{r}    
UP_LC.spdf = subset(LCLU_NWF.spdf, 
                    LANDUSE_CO >= 2600 & 
                    LANDUSE_CO <= 4430 )

Wet_LC.spdf = subset(LCLU_NWF.spdf, 
                     LANDUSE_CO >= 5000 & 
                     LANDUSE_CO <= 6999 )
```

###Crop soils data
```{r}
UP_Soils.spdf = crop(Raw_Soils.spdf, UP_LC.spdf) 
UP_Soils.spdf@data = UP_Soils.spdf@data %>%
                     mutate(Designation = 0)


Wet_Soils.spdf = crop(Raw_Soils.spdf, Wet_LC.spdf)
Wet_Soils.spdf@data = Wet_Soils.spdf@data %>%
                      mutate(Designation = 1)
```

```{r}
UP_Soils1.spdf = spChFIDs(UP_Soils.spdf, 
                          paste(as.character(
                                1:nrow(UP_Soils.spdf)),"U", sep = ""))

Wet_Soils1.spdf = spChFIDs(Wet_Soils.spdf, 
                           paste(as.character(
                                1:nrow(Wet_Soils.spdf)),"W", sep = ""))

Soils.spdf = spRbind(UP_Soils1.spdf, Wet_Soils1.spdf)

Soils.spdf$IDs = 1:nrow(Soils.spdf)
```

###Combine Upland and Wetland Data Frames
```{r}
Soils.df = Soils.spdf@data

Soils0.df = subset(Soils.df, 
                   select = -c(AREASYMBOL,  SPATIALVER, NationalMu,  
                                muhelcl,  muwathelcl,  muwndhelcl,  interpfocu, 
                                invesinten,  lkey,  iacornsr,  projectsca,  tabularver, 
                                iccdcd,   iccdcdpct,  engstafdcd,  engstafll,  engstafml, 
                                albedo_h,  albedo_l,  cropprodin,  rsprod_h,  rsprod_l, 
                                rsprod_r,  slopelen_h,  slopelen_l,  cokey,  comppct_l,   
                                comppct_h,  compkind,  earthcovki,  earthcov_1,  aspectccwi, 
                                aspectrep,  aspectcwis,  geomdesc,  nirrcapuni,  irrcapcl, 
                                irrcapscl,  irrcapunit,  constreesh,  soilslippo,  frostact, 
                                soiltaxedi,  taxclname,  taxorder,  taxsuborde,  taxgrtgrou, 
                                taxsubgrp,  taxparts_1, map_h,  map_l,	map_r, Shape_Leng, Shape_Area))

Soils1.df = as.data.frame(lapply
                          (Soils0.df, factor))
Soils2.df = Soils1.df %>%
            mutate(Designation = as.numeric(Soils.df$Designation),
                   IDs = as.numeric(Soils.df$IDs),
                   wtdepaprju = as.numeric(round(Soils.df$wtdepaprju),5),
                   wtdepannmi = as.numeric(round(Soils.df$wtdepannmi),5),
                   slopegradd = as.numeric(round(Soils.df$slopegradd),5),
                   slopegradw = as.numeric(round(Soils.df$slopegradw), 5),
                   aws025wta = as.numeric(round(Soils.df$aws025wta), 5),
                   aws050wta = as.numeric(round(Soils.df$aws050wta), 5),
                   aws0100wta = as.numeric(round(Soils.df$aws0100wta), 5),
                   aws0150wta = as.numeric(round(Soils.df$aws0150wta), 5),
                   niccdcdpct = as.numeric(round(Soils.df$niccdcdpct), 5),
                   albedo_r = as.numeric(round(Soils.df$albedo_r), 5),
                   elev_h = as.numeric(round(Soils.df$elev_h), 5),
                   elev_l = as.numeric(round(Soils.df$elev_l), 5),
                   elev_r = as.numeric(round(Soils.df$elev_r), 5),
                   slope_h = as.numeric(round(Soils.df$slope_h), 5),
                   slope_r = as.numeric(round(Soils.df$niccdcdpct), 5))
```

###Prior Distribution
```{r}
D0 = 0.33 #Prob of wetlands in Florida
D1 = 0.50 #Prop of being wetland if known to have wetland vegetation

Soils.spdf$Extent = gArea(Soils.spdf,
                          byid = TRUE)

Wet_area = as.numeric(
             Soils.spdf@data %>%
                       filter(Designation == 1) %>%
                       summarise(sum(Extent, na.rm = TRUE)))

Up_area = as.numeric(
            Soils.spdf@data %>%
                      filter(Designation == 0) %>%
                      summarise(sum(Extent, na.rm = TRUE)))

Wp = (Wet_area/(Wet_area + Up_area))
Up = (Up_area/(Wet_area + Up_area))

Pr = (Up*D0) + (Wp*D1)

q1 = list(p = .5, x = Pr)
q2 = list(p = .9, x = D1)
B.select = beta.select(q1, q2) 

a = B.select[1]
b = B.select[2]

hyper.p = list(prec = list(
                        list(prior = "logitbeta", 
                             param = c(a, b),
                             initial = 0)))
```

###Conduct Principal Components Analysis (PCA)
``` {r}
Soils.PCA = Soils2.df %>%
                select(slopegradd, slopegradw, aws025wta, aws050wta, aws0100wta,
                aws0150wta, niccdcdpct, albedo_r, elev_h, elev_l, elev_r, slope_h, 
                slope_r, wtdepaprju, wtdepannmi)

PCA.Result = PCA(Soils.PCA , 
                 scale.unit = TRUE, 
                 ncp = 5, 
                 graph = FALSE)
```

###Singular Value Decomposition (SVD) to Data Frame
```{r}
PCA.df = as.data.frame(PCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```

###Conduct Multiple Correspondance Analysis (MCA)
``` {r}
Soils.MCA = Soils2.df %>%
               select(MUSYM, muname, mukind, farmlndcl, museq, brockdepmi, 
                      flodfreqdc, flodfreqma, pondfreqpr, drclassdcd, 
                      drclasswet, hydgrpdcd, niccdcd, engdwobdcd, engdwbdcd,  engdwbll,  
                      engdwbml,   engsldcd,   engsldcp, englrsdcd,  engcmssdcd, engcmssmp, 
                      urbrecptdc, urbrecptwt, forpehrtdc, hydclprs, awmmfpwwta, airtempa_h, 
                      airtempa_l, airtempa_r, ffd_h, ffd_l, ffd_r, initsub_h, initsub_l, 
                      initsub_r, slope_l, slopelen_r, totalsub_h, totalsub_l, totalsub_r, 
                      compname, otherph, localphase, runoff, tfact, wei, weg, erocl, 
                      hydricon, nirrcapcl, nirrcapscl, foragesuit, wlgrai, wlgrass, wlherbaceo,
                      wlshrub, wlconifero, wlhardwood, wlwetplant, wlshalloww, wlrangelan, 
                      wlopenland, wlwoodland, wlwetland, corcon, corsteel, taxpartsiz, 
                      taxceactcl, taxreactio, taxtempcl, taxmoistsc, taxtempreg)

MCA.Result = MCA(Soils.MCA, 
                 ncp=5, 
                 graph = FALSE)
```

###MCA Singular Value Decomposition (SVD) to .df
Pull SVD values from the MCA and add the associated Wetland/Upland "Designation" in a new data frame.
```{r}
MCA.df = as.data.frame(MCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```

###Combine Significant MCA and PCA Results
```{r}
Soils2.spdf = Soils.spdf

Soils2.spdf@data = PCA.df %>%
                   select(Designation, V1, V2, V3) %>%
                   mutate(MCA3 = MCA.df[,"V3"],
                          MUKEY = as.numeric(Soils.spdf@data[,"MUKEY"]))
```

###Convert Soils PCA and MCA Results to Raster Objects
First, create a raster template based on the resolution specified at top of the script.
```{r}
Blank.r = raster(nrows = yROW, ncols = xCOL)
extent(Blank.r) = extent(Soils2.spdf)
proj4string(Blank.r) = proj4string(Soils2.spdf)
```

###Create Wetland/Upland Designation Raster
```{r}
w_rast = rasterize(Wet_Soils.spdf,
                   Blank.r,
                   field = 1)

w_rast = reclassify(w_rast,
                    cbind(NA, 0))
```

###Create Rasters for Significatnt PCA/MCA Results
```{r}
V1_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V1)

V2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V2)

V3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V3)

MCA3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$MCA3)
```

###Convert Rasters to SpatialPolygonsDataFrame
```{r}
Wetlands.spdf = as(w_rast, "SpatialPolygonsDataFrame")
names(Wetlands.spdf) = "Designation"

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(V1 = values(V1_rast),
                               V2 = values(V2_rast),
                               V3 = values(V3_rast),
                               MCAV3 = values(MCA3_rast))
```

##Soil Available Water Capacity (AWC) and Organic Mass (OM)
###Rasterize MUKEY 
```{r}
AWC.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)

OM.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)
```

###Soil Functions
```{r}
HzWS = function(i) {
              wt = i$comppct_r[1]  
              thick = with(i, hzdepb_r - hzdept_r)  
              whc = thick * i$awc_r 
            	whc.total = sum(whc, na.rm=TRUE)  
	            data.frame(whc = whc.total, wt=wt)  
}

HzWSO = function(i) {
              wto = i$comppct_r[1]  
              thicko = with(i, hzdepb_r - hzdept_r)  
              whco = thicko * i$Om_r  
            	whc.totalo = sum(whco, na.rm=TRUE)   
	            data.frame(whco = whc.totalo, wto=wto)  
}
```


```{r}
MU_mean = function(i) {
	              whc = wtd.mean(i$whc, weights=i$wt)  
	              data.frame(whc=whc)  
}

MU_meano = function(i) {
	              whco = wtd.mean(i$whco, weights=i$wto)  
	              data.frame(whco=whco)  
}
```

###Add Raster Attribute Table (RAT)
```{r}
AWC.r = ratify(AWC.r,
               count = TRUE)

OM.r = ratify(OM.r,
               count = TRUE)
```

###save RATs as Objects
```{r}
rat = levels(AWC.r)[[1]]

rato = levels(OM.r)[[1]]
```

###Extract MUKEYs from the RAT
```{r}
in.statement = format_SQL_in_statement(rat$ID)

in.statement2 = format_SQL_in_statement(rato$ID)
```


###Query SDA
```{r}
q = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

ACW.res = SDAquery(q) 
```

```{r}
q2 = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

OM.res = SDAquery(q2) 
```

###Aggregate Data
```{r}
co.whc = ACW.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWS(.))

mu.whc = co.whc %>% 
              group_by(mukey) %>% 
              do(MU_mean(.))

co.whco = OM.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWSO(.))

mu.whco = co.whco %>% 
              group_by(mukey) %>% 
              do(MU_meano(.))
```

###Join Results to Domain Rasters
```{r}
names(mu.whc)[1] = 'ID'
rat.new = left_join(rat, mu.whc)
levels(AWC.r) = rat.new
AWC = deratify(AWC.r, att='whc')

names(mu.whco)[1] = 'ID'
rato.new = left_join(rato, mu.whco)
levels(OM.r) = rato.new
OM = deratify(OM.r, att='whco')
```

###Add Results to Wetlands.spdf
```{r}
Wetlands.spdf$AWC = values(AWC)
Wetlands.spdf$OM = values(OM)
```

###Explanatory Variables linked to Topograpy
```{r}
#DEM (USGS 1/3 arc-sec)
      DEM = raster("./WetlandData/DEM_NWF/dem_nwf/w001001.adf")
      DEM = reclassify(DEM, 
                        cbind(0, 0.001))
      
      DomainB = readOGR(dsn = "./WetlandData/Domains/Domain300", 
                        layer = "Domain300", 
                        stringsAsFactors = FALSE)
      
      DomainBp = spTransform(DomainB, 
                       CRS(projection(DEM)))
      
      DEM = crop(DEM, DomainBp)
```

###Calculate Topographic Indicies
```{r}
RR = raster(nrow = yROW, ncol = xCOL)
extent(RR) = extent(DEM)

DEM2 = resample(DEM, RR, 
                method='bilinear')

tpi = terrain(DEM2, 
              opt = 'tpi')

TPI = reclassify(tpi, 
                 cbind(NA, minValue(tpi)))

proj4string(TPI) = proj4string(LCLU_NWF.spdf)
extent(TPI) = extent(LCLU_NWF.spdf)

Wetlands.spdf$TPI = values(TPI)
```

```{r}
CTI0 = upslope.area(DEM, 
                    log = TRUE, 
                    atb = TRUE, 
                    deg = 0.1)

CTI = reclassify(CTI0$atb, 
                 cbind(NA, maxValue(CTI0)))

extent(CTI) = extent(LCLU_NWF.spdf)
CTI = resample(CTI, Blank.r, method = 'bilinear')

Wetlands.spdf$CTI = values(CTI)
```

##Bayesian Analysis
###Assign Region and IDs Labels
```{r}
Wetlands.spdf$Region = 1:nrow(Wetlands.spdf)
```

###Spatial Neighborhood as an INLA Graph
```{r}
nb = poly2nb(Wetlands.spdf, queen = FALSE)
nb2INLA("J", nb)
J = inla.read.graph("J")
```

###Run Previously Fitted Model
```{r}
D300ST = Sys.time()

formula7 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model7_300  =  inla(formula7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model7_300)

#Exponentiate
FIX(model7_300)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M7cSLPM = model7_300$summary.linear.predictor[,"mean"],
                               M7cProb = exp(M7cSLPM)/(1+exp(M7cSLPM)))

D300ET = Sys.time()
D300Time = as.numeric(D300ET - D300ST, units = "mins")
D300cnt = length(Wetlands.spdf@data$Designation)
```

###Wetland Probabilty Map
```{r}
M300 = Blank.r
values(M300) = Wetlands.spdf@data$M7cProb

rng = seq(0, 1, 0.10)
rngL = paste(rng*100, '%', sep = "")
cr = brewer.pal(10, "BrBG")
M300p = levelplot(M300, margin = FALSE, 
          sub = "Probabilty of Wetland Presence             ",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))

M300p
```

###Figure 4 (Compare Prediction to the NWI)
```{r}
M2p = Blank.r
values(M2p) = Wetlands.spdf@data$M7cProb

NWI = readOGR(dsn = "./WetlandData/NWI/Domain300", 
              layer = "NWI_D300", 
              stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
              gIsValid(NWI)
              NWI = gBuffer(NWI, width=0, byid=TRUE)
                    
nwi.r = rasterize(NWI,
                  Blank.r,
                  field = 1)
                    
nwi.r = reclassify(nwi.r, 
                     cbind(NA, 0))

Wetlands.spdf$NWI = values(nwi.r)

nwi2.r= reclassify(nwi.r, 
                     cbind(1, NA))

Wet_Change = sum(nwi2.r, M2p)

stack <- stack(M2p, nwi.r, Wet_Change)
names(stack) = c("Model", "NWI", "Compare")


rng = seq(0, 1, 0.1)
rngL = paste(rng*100, '%', sep = "")
cr = rev(topo.colors(10))
levelplot(stack, 
          layout=c(3, 1),
          margin = FALSE, 
          sub = NULL,
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(space = "bottom", 
                          at = rng, 
                          labels = rngL, 
                          col = cr),
          par.settings = list(fontsize = list(text = 13)))


PD_NWIcnt = sum(Wetlands.spdf@data$NWI)

PDwCells.df = filter(Wetlands.spdf@data, 
                     M7cProb >= 0.5)

PDwCells = length(PDwCells.df$M7cProb)

WetDiffPD = ((PDwCells - PD_NWIcnt)/PD_NWIcnt)*100

PD_NWIcnt
PDwCells
WetDiffPD
```

###Figure 3 (Compare Response)
```{r}
detach("package:soilDB", unload=TRUE)
detach("package:aqp", unload=TRUE)

Fitted.df = as.data.frame(cbind(Run = rep("Fitted", 35),
                            V1 = (exp(-model7$marginals.fixed$V1[, 1]) - 1) * 100,
                            V2 = (exp(-model7$marginals.fixed$V2[, 1]) - 1) * 100,
                            V3 = (exp(-model7$marginals.fixed$V3[, 1]) - 1) * 100,
                            TPI = (exp(-model7$marginals.fixed$TPI[, 1]) - 1) * 100,
                            CTI = (exp(-model7$marginals.fixed$CTI[, 1]) - 1) * 100,
                            AWC = (exp(-model7$marginals.fixed$AWC[, 1]) - 1) * 100,
                            OM = (exp(-model7$marginals.fixed$OM[, 1]) - 1) * 100))

D200.df = as.data.frame(cbind(Run = rep("D200", 35),
                              V1 = (exp(-model7_200$marginals.fixed$V1[, 1]) - 1) * 100,
                              V2 = (exp(-model7_200$marginals.fixed$V2[, 1]) - 1) * 100,
                              V3 = (exp(-model7_200$marginals.fixed$V3[, 1]) - 1) * 100,
                              TPI = (exp(-model7_200$marginals.fixed$TPI[, 1]) - 1) * 100,
                              CTI = (exp(-model7_200$marginals.fixed$CTI[, 1]) - 1) * 100,
                              AWC = (exp(-model7_200$marginals.fixed$AWC[, 1]) - 1) * 100,
                              OM = (exp(-model7_200$marginals.fixed$OM[, 1]) - 1) * 100))

D300.df = as.data.frame(cbind(Run = rep("D300", 35),
                              V1 = (exp(-model7_300$marginals.fixed$V1[, 1]) - 1) * 100,
                              V2 = (exp(-model7_300$marginals.fixed$V2[, 1]) - 1) * 100,
                              V3 = (exp(-model7_300$marginals.fixed$V3[, 1]) - 1) * 100,
                              TPI = (exp(-model7_300$marginals.fixed$TPI[, 1]) - 1) * 100,
                              CTI = (exp(-model7_300$marginals.fixed$CTI[, 1]) - 1) * 100,
                              AWC = (exp(-model7_300$marginals.fixed$AWC[, 1]) - 1) * 100,
                              OM = (exp(-model7_300$marginals.fixed$OM[, 1]) - 1) * 100))

Res30.df = as.data.frame(cbind(Run = rep("Res30", 35),
                               V1 = (exp(-model7_30$marginals.fixed$V1[, 1]) - 1) * 100,
                               V2 = (exp(-model7_30$marginals.fixed$V2[, 1]) - 1) * 100,
                               V3 = (exp(-model7_30$marginals.fixed$V3[, 1]) - 1) * 100,
                               TPI = (exp(-model7_30$marginals.fixed$TPI[, 1]) - 1) * 100,
                               CTI = (exp(-model7_30$marginals.fixed$CTI[, 1]) - 1) * 100,
                               AWC = (exp(-model7_30$marginals.fixed$AWC[, 1]) - 1) * 100,
                               OM = (exp(-model7_30$marginals.fixed$OM[, 1]) - 1) * 100))

Res70.df = as.data.frame(cbind(Run = rep("Res70", 35),
                               V1 = (exp(-model7_70$marginals.fixed$V1[, 1]) - 1) * 100,
                               V2 = (exp(-model7_70$marginals.fixed$V2[, 1]) - 1) * 100,
                               V3 = (exp(-model7_70$marginals.fixed$V3[, 1]) - 1) * 100,
                               TPI = (exp(-model7_70$marginals.fixed$TPI[, 1]) - 1) * 100,
                               CTI = (exp(-model7_70$marginals.fixed$CTI[, 1]) - 1) * 100,
                               AWC = (exp(-model7_70$marginals.fixed$AWC[, 1]) - 1) * 100,
                               OM = (exp(-model7_70$marginals.fixed$OM[, 1]) - 1) * 100))

ResultsE.df = rbind(Fitted.df, D200.df, D300.df)
ResultsR.df = rbind(Fitted.df, Res30.df, Res70.df)

FWE.df = melt(ResultsE.df, "Run")
FWE.df$value = as.numeric(FWE.df$value)

FWR.df = melt(ResultsR.df, "Run")
FWR.df$value = as.numeric(FWR.df$value)

plotEXT = ggplot(FWE.df, aes(value, fill = as.factor(Run))) + 
                 stat_density(adjust = 2, 
                 position = "identity", 
                 color = "black", alpha = 0.5) +
                 scale_fill_brewer(palette="Dark2") + 
                 theme_classic() +
                 facet_wrap(~ variable,
                          scales = "free",
                          ncol = 1) +
                 xlab(NULL) +
                 ylab(NULL) +
                 theme(legend.position="bottom") +
                 labs(title = "Extent",
                    fill = "Model") + 
                 geom_vline(data = FWE.df, 
                 aes(xintercept = 0,
                     colour=Run),
                     linetype = "dotted",
                     size = 1, col = "red")


plotRES = ggplot(FWR.df, aes(value, fill = as.factor(Run))) + 
                 stat_density(adjust = 2, 
                 position = "identity", 
                 color = "black", alpha = 0.5) +
                 scale_fill_brewer(palette="Dark2") + 
                 theme_classic() +
                 facet_wrap(~ variable,
                          scales = "free",
                          ncol = 1) +
                 xlab(NULL) +
                 ylab("Posterior Density") +
                 theme(legend.position="bottom", 
                       axis.title.y = element_text(size = 25)) +
                 labs(title = "Resolution",
                    fill = "Model") + 
                 geom_vline(data = FWR.df, 
                 aes(xintercept = 0,
                     colour=Run),
                     linetype = "dotted",
                     size = 1, col = "red")

grid.arrange(plotRES, plotEXT, ncol = 2)
```

###Comparison to NWI
```{r}
#Brier score (Training Set)
BSNW.df = filter(Wetlands.spdf@data, Designation == 1)
BSTrn = mean((BSNW.df$M7cProb - 1)^2)

BSNW.df = filter(Wetlands.spdf@data, Designation == 0)
BSTrnU = mean((BSNW.df$M7cProb - 1)^2)

BScnt.df = filter(Wetlands.spdf@data, M7cProb >= 0.49)
Cnt300 = length(BScnt.df$M7cProb)

#Brier score (NWI)
BSNWI.df = filter(Wetlands.spdf@data, NWI == 1)
BSNWI = mean((BSNWI.df$M7cProb - 1)^2)
NWI300Cnt = length(BSNWI.df$NWI)

BSNWI.df = filter(Wetlands.spdf@data, NWI == 0)
BSNWIU = mean((BSNWI.df$M7cProb - 1)^2)

Brier = as.data.frame(rbind(BST300 =BSTrn, 
                            BSTU300 = BSTrnU, 
                            Cnt300 = Cnt300, 
                            BSNWI300 = BSNWI, 
                            BSNWIU300 = BSNWIU, 
                            NWI300cnt = NWI300Cnt))
Brier

NWI_Mod300 = ((Cnt300 - NWI300Cnt)/NWI300Cnt)*100

#Change relative to NWI:
NWI_Mod300
```

###Model Run Times
```{r}
Time.df = as.data.frame(rbind(D70Time, D100Time, D200Time, D30Time, D300Time))
colnames(Time.df) = "Time"

Time.df$Cnts = c(D70cnt, D100cnt, D200cnt, D30cnt, D300cnt)

TimeS = arrange(Time.df, Cnts)
rownames(TimeS) = c("Domain 3\n(100, 70)", 
            "Domain 1\n(100, 50)", 
            "Domain 4\n(200, 50)", 
            "Domain 2\n(100, 30)", 
            "Domain 5\n(300, 50)")

ggplot(TimeS, aes(Cnts, Time, label= rownames(TimeS))) + 
       geom_point() +
       geom_text(hjust=0.5, vjust=1.25) +
       theme_classic() +
       stat_smooth(method = "lm", 
                   col = "red") +
       xlab("Number of Cells") +
       ylab("Run Time (mins)") +
       theme(axis.title.y = element_text(size = 15),
             axis.title.x = element_text(size = 15))

TimeS
```


```{r}
rm(list=setdiff(ls(), c("model7", "model7_30", "model7_70", "model7_200", "model7_300", "Brier",
                        "SDAquery", "Time.df", "FIX")))
```





Changing Domain Location
=========================
The sensitivity of the model to changes in location is explored below by first relocating the domain to different portion of the same physiographic province as the primary domain and then to a location in southwest Florida.  The selected model ("model7") is applied to both domains holding resolution constant for both with a cell edge of 50m.

Study Area Domain NW
----------------------
```{r}

Map = get_map(location = c(-84.13, 30.30), 
              source = "google",
              zoom = 12,
              color = "color",
              maptype = "terrain")
p1 = ggmap(Map, dev = "extent") +
  geom_segment(aes(x = -84.18281, xend = -84.07878 , y = 30.36819, yend = 30.36819), 
             color = "red") +
  geom_segment(aes(x = -84.18281, xend = -84.07878 , y = 30.27797  , yend = 30.27797  ), 
             color = "red") +
  geom_segment(aes(x = -84.18281, xend = -84.18281, y = 30.36819, yend = 30.27797  ), 
             color = "red") +
  geom_segment(aes(x = -84.07878 , xend = -84.07878 , y = 30.36819, yend = 30.27797  ), 
             color = "red") + 
  labs(x = expression(paste("Longitude (", degree, "W)")), 
       y = expression(paste("Latitude (", degree, "N)")))

source('./WetlandData/ScaleBar/ScaleBarNorth.R')

p1b = p1 + scaleBar(lon = -84.232,
                    lat = 30.21, 
                    distanceLon = 5,
                    distanceLat = 1,
                    distanceLegend = 1.5,
                    dist.unit = "km",
                    arrow.length = 3,
                    arrow.distance = 2,
                    arrow.North.size = 12)

p1b + theme(panel.grid.minor = element_line(colour = NA), 
            panel.grid.minor = element_line(colour = NA),
            panel.background = element_rect(fill = NA, colour = NA), 
            rect = element_blank())
```

```{r}
graphics.off()
```


###Domain Target Cell Size (TCS)
```{r}
TCS = 50 #Raster cell edge length (meters)

xCOL = ceiling(10000/TCS)
yROW = ceiling(10000/TCS)
```

###Read Soil and Landuse/Landcover Shapefiles
```{r}
#Soils Data
    Raw_Soils.spdf = readOGR(dsn = "./WetlandData/SSURGO_NW2", layer = "SSURGO_NW2", 
                     stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                     gIsValid(Raw_Soils.spdf) #Chk TopologY
                     Raw_Soils.spdf = gBuffer(Raw_Soils.spdf, width=0, byid=TRUE) #Fix Topology

#Landcover/Landuse Data
    LCLU_NWF.spdf = readOGR(dsn = "./WetlandData/LCLU_NW2", layer = "LCLU_NW2", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    gIsValid(LCLU_NWF.spdf)
                    LCLU_NWF.spdf = gBuffer(LCLU_NWF.spdf, width=0, byid=TRUE)   
```

###Subset Landcover Groups
```{r}    
UP_LC.spdf = subset(LCLU_NWF.spdf, 
                    LANDUSE_CO >= 2600 & 
                    LANDUSE_CO <= 4430 )

Wet_LC.spdf = subset(LCLU_NWF.spdf, 
                     LANDUSE_CO >= 5000 & 
                     LANDUSE_CO <= 6999 )
```

###Crop soils data
```{r}
UP_Soils.spdf = crop(Raw_Soils.spdf, UP_LC.spdf) 
UP_Soils.spdf@data = UP_Soils.spdf@data %>%
                     mutate(Designation = 0)


Wet_Soils.spdf = crop(Raw_Soils.spdf, Wet_LC.spdf)
Wet_Soils.spdf@data = Wet_Soils.spdf@data %>%
                      mutate(Designation = 1)
```

```{r}
UP_Soils1.spdf = spChFIDs(UP_Soils.spdf, 
                          paste(as.character(
                                1:nrow(UP_Soils.spdf)),"U", sep = ""))

Wet_Soils1.spdf = spChFIDs(Wet_Soils.spdf, 
                           paste(as.character(
                                1:nrow(Wet_Soils.spdf)),"W", sep = ""))

Soils.spdf = spRbind(UP_Soils1.spdf, Wet_Soils1.spdf)

Soils.spdf$IDs = 1:nrow(Soils.spdf)
```

###Prior Distribution
To quantify current understanding:
```{r}
D0 = 0.33 #Prob of wetlands in Florida
D1 = 0.50 #Prop of being wetland if known to have wetland vegetation

Soils.spdf$Extent = gArea(Soils.spdf,
                          byid = TRUE)

Wet_area = as.numeric(
             Soils.spdf@data %>%
                       filter(Designation == 1) %>%
                       summarise(sum(Extent, na.rm = TRUE)))

Up_area = as.numeric(
            Soils.spdf@data %>%
                      filter(Designation == 0) %>%
                      summarise(sum(Extent, na.rm = TRUE)))

Wp = (Wet_area/(Wet_area + Up_area))
Up = (Up_area/(Wet_area + Up_area))

Pr = (Up*D0) + (Wp*D1)
```

```{r}
q1 = list(p = .5, x = Pr)
q2 = list(p = .9, x = D1)
B.select = beta.select(q1, q2) 

a = B.select[1]
b = B.select[2]
```

```{r}
hyper.p = list(prec = list(
                        list(prior = "logitbeta", 
                             param = c(a, b),
                             initial = 0)))
```

###Combine Upland and Wetland Data Frames
```{r}
Soils.df = Soils.spdf@data

Soils0.df = subset(Soils.df, 
                   select = -c(AREASYMBOL,  SPATIALVER, NationalMu,  
                                muhelcl,  muwathelcl,  muwndhelcl,  interpfocu, 
                                invesinten,  lkey,  iacornsr,  projectsca,  tabularver, 
                                iccdcd,   iccdcdpct,  engstafdcd,  engstafll,  engstafml, 
                                albedo_h,  albedo_l,  cropprodin,  rsprod_h,  rsprod_l, 
                                rsprod_r,  slopelen_h,  slopelen_l,  cokey,  comppct_l,   
                                comppct_h,  compkind,  earthcovki,  earthcov_1,  aspectccwi, 
                                aspectrep,  aspectcwis,  geomdesc,  nirrcapuni,  irrcapcl, 
                                irrcapscl,  irrcapunit,  constreesh,  soilslippo,  frostact, 
                                soiltaxedi,  taxclname,  taxorder,  taxsuborde,  taxgrtgrou, 
                                taxsubgrp,  taxparts_1, map_h,  map_l,	map_r, Shape_Leng, Shape_Area))

Soils1.df = as.data.frame(lapply
                          (Soils0.df, factor))
Soils2.df = Soils1.df %>%
            mutate(Designation = as.numeric(Soils.df$Designation),
                   IDs = as.numeric(Soils.df$IDs),
                   wtdepaprju = as.numeric(round(Soils.df$wtdepaprju),5),
                   wtdepannmi = as.numeric(round(Soils.df$wtdepannmi),5),
                   slopegradd = as.numeric(round(Soils.df$slopegradd),5),
                   slopegradw = as.numeric(round(Soils.df$slopegradw), 5),
                   aws025wta = as.numeric(round(Soils.df$aws025wta), 5),
                   aws050wta = as.numeric(round(Soils.df$aws050wta), 5),
                   aws0100wta = as.numeric(round(Soils.df$aws0100wta), 5),
                   aws0150wta = as.numeric(round(Soils.df$aws0150wta), 5),
                   niccdcdpct = as.numeric(round(Soils.df$niccdcdpct), 5),
                   albedo_r = as.numeric(round(Soils.df$albedo_r), 5),
                   elev_h = as.numeric(round(Soils.df$elev_h), 5),
                   elev_l = as.numeric(round(Soils.df$elev_l), 5),
                   elev_r = as.numeric(round(Soils.df$elev_r), 5),
                   slope_h = as.numeric(round(Soils.df$slope_h), 5),
                   slope_r = as.numeric(round(Soils.df$niccdcdpct), 5))
```

###Conduct Principal Components Analysis (PCA)
``` {r}
Soils.PCA = Soils2.df %>%
                select(slopegradd, slopegradw, aws025wta, aws050wta, aws0100wta,
                aws0150wta, niccdcdpct, albedo_r, elev_h, elev_l, elev_r, slope_h, 
                slope_r, wtdepaprju, wtdepannmi)

PCA.Result = PCA(Soils.PCA , 
                 scale.unit = TRUE, 
                 ncp = 5, 
                 graph = FALSE)
```

###Singular Value Decomposition (SVD) to Data Frame
```{r}
PCA.df = as.data.frame(PCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```
 
###Verify Significance of PCA
```{r}
PCAfnw = Designation ~ V1 + V2 + V3 + V4 + V5

PCAnw  =  inla(PCAfnw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = PCA.df)
summary(PCAnw)

PCAfnw2 = Designation ~ V1

PCAnw2  =  inla(PCAfnw2, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = PCA.df)
summary(PCAnw2)
```

###Conduct Multiple Correspondance Analysis (MCA)
``` {r}
Soils.MCA = Soils2.df %>%
               select(MUSYM, muname, mukind, farmlndcl, museq, brockdepmi, 
                      flodfreqdc, flodfreqma, pondfreqpr, drclassdcd, 
                      drclasswet, hydgrpdcd, niccdcd, engdwobdcd, engdwbdcd,  engdwbll,  
                      engdwbml,   engsldcd,   engsldcp, englrsdcd,  engcmssdcd, engcmssmp, 
                      urbrecptdc, urbrecptwt, forpehrtdc, hydclprs, awmmfpwwta, airtempa_h, 
                      airtempa_l, airtempa_r, ffd_h, ffd_l, ffd_r, initsub_h, initsub_l, 
                      initsub_r, slope_l, slopelen_r, totalsub_h, totalsub_l, totalsub_r, 
                      compname, otherph, localphase, runoff, tfact, wei, weg, erocl, 
                      hydricon, nirrcapcl, nirrcapscl, foragesuit, wlgrai, wlgrass, wlherbaceo,
                      wlshrub, wlconifero, wlhardwood, wlwetplant, wlshalloww, wlrangelan, 
                      wlopenland, wlwoodland, wlwetland, corcon, corsteel, taxpartsiz, 
                      taxceactcl, taxreactio, taxtempcl, taxmoistsc, taxtempreg)

MCA.Result = MCA(Soils.MCA, 
                 ncp=5, 
                 graph = FALSE)
```

###MCA Singular Value Decomposition (SVD) to .df
```{r}
MCA.df = as.data.frame(MCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```

###Verify Significance of MCA
```{r}
MCAfnw = Designation ~ V1 + V2 + V3 + V4 + V5

MCAnw  =  inla(MCAfnw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = MCA.df)
summary(MCAnw)
```

###Combine Significant MCA and PCA Results
Also adding variables used in model7 of the primary domain
```{r}
Soils2.spdf = Soils.spdf

Soils2.spdf@data = PCA.df %>%
                   select(Designation, V1, V2, V3) %>%
                   mutate(MUKEY = as.numeric(Soils.spdf@data[,"MUKEY"]))
```

###Convert Soils PCA and MCA Results to Raster Objects
```{r}
Blank.r = raster(nrows = yROW, ncols = xCOL)
extent(Blank.r) = extent(Soils2.spdf)
proj4string(Blank.r) = proj4string(Soils2.spdf)
```

###Create Wetland/Upland Designation Raster
```{r}
w_rast = rasterize(Wet_Soils.spdf,
                   Blank.r,
                   field = 1)

w_rast = reclassify(w_rast,
                    cbind(NA, 0))
```

###Create Rasters for Significatnt PCA/MCA Results
```{r}
V1_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V1)

V2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V2)

V3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V3)
```

###Convert Rasters to SpatialPolygonsDataFrame
Add PCA and MCA results
```{r}
Wetlands.spdf = as(w_rast, "SpatialPolygonsDataFrame")
names(Wetlands.spdf) = "Designation"

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(V1 = values(V1_rast),
                               V2 = values(V2_rast),
                               V3 = values(V3_rast))
```


###Additional Libraries are Needed
```{r}
#install.packages('Hmisc', dep=TRUE)
suppressMessages(library(Hmisc))

#install.packages('soilDB', dep=TRUE) #from CRAN + dependencies
#install.packages("soilDB", repos="http://R-Forge.R-project.org") # most recent from r-forge
suppressMessages(library(soilDB))

#install.packages("SSOAP", repos = "http://www.omegahat.org/R", type="source") # SSOAP, XMLSchema
suppressMessages(library(SSOAP))
```


##Soil Available Water Capacity (AWC) and Organic Mass (OM)
###Rasterize MUKEY 
```{r}
AWC.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)

OM.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)
```

###Soil Functions
```{r}
HzWS = function(i) {
              wt = i$comppct_r[1]  
              thick = with(i, hzdepb_r - hzdept_r)  
              whc = thick * i$awc_r 
            	whc.total = sum(whc, na.rm=TRUE)  
	            data.frame(whc = whc.total, wt=wt)  
}

HzWSO = function(i) {
              wto = i$comppct_r[1]  
              thicko = with(i, hzdepb_r - hzdept_r)  
              whco = thicko * i$Om_r  
            	whc.totalo = sum(whco, na.rm=TRUE)   
	            data.frame(whco = whc.totalo, wto=wto)  
}
```

```{r}
MU_mean = function(i) {
	              whc = wtd.mean(i$whc, weights=i$wt)  
	              data.frame(whc=whc)  
}

MU_meano = function(i) {
	              whco = wtd.mean(i$whco, weights=i$wto)  
	              data.frame(whco=whco)  
}
```

###Add Raster Attribute Table (RAT)
```{r}
AWC.r = ratify(AWC.r,
               count = TRUE)

OM.r = ratify(OM.r,
               count = TRUE)
```

###save RATs as Objects
```{r}
rat = levels(AWC.r)[[1]]

rato = levels(OM.r)[[1]]
```

###Extract MUKEYs from the RAT
```{r}
in.statement = format_SQL_in_statement(rat$ID)

in.statement2 = format_SQL_in_statement(rato$ID)
```

###Query SDA
```{r}
q = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

ACW.res = SDAquery(q) 
```

```{r}
q2 = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

OM.res = SDAquery(q2) 
```

###Aggregate Data
```{r}
co.whc = ACW.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWS(.))

mu.whc = co.whc %>% 
              group_by(mukey) %>% 
              do(MU_mean(.))

co.whco = OM.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWSO(.))

mu.whco = co.whco %>% 
              group_by(mukey) %>% 
              do(MU_meano(.))
```

###Join Results to Domain Rasters
```{r}
names(mu.whc)[1] = 'ID'
rat.new = left_join(rat, mu.whc)
levels(AWC.r) = rat.new
AWC = deratify(AWC.r, att='whc')

names(mu.whco)[1] = 'ID'
rato.new = left_join(rato, mu.whco)
levels(OM.r) = rato.new
OM = deratify(OM.r, att='whco')
```

###Add Results to Wetlands.spdf
```{r}
Wetlands.spdf$AWC = values(AWC)
Wetlands.spdf$OM = values(OM)
```


###Verify Significance of AWC and OM
```{r}
AWCfnw = Designation ~ AWC

AWCnw  =  inla(AWCfnw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(AWCnw)


OMfnw = Designation ~ OM

OMnw  =  inla(OMfnw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(OMnw)
```

###Soil Adjusted Vegetation Index (SAVI)
```{r}
Band4 = raster("./WetlandData/LS8_NW2/band4_nw2/w001001.adf")

Band5 = raster("./WetlandData/LS8_NW2/band5_nw2/w001001.adf")
      
savi = ((Band5 - Band4) / (Band5 + Band4 + 0.5)) * (1.5)

extent(savi) = extent(Blank.r)

SAVI = resample(savi, Blank.r, 
                method = 'bilinear')

Wetlands.spdf$SAVI = values(SAVI)
```


###Verify Significance of SAVI
```{r}
Form5nw = Designation ~ SAVI

SAVInw  =  inla(Form5nw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(SAVInw)
```

###Explanatory Variables linked to Topograpy
```{r}
#DEM (USGS 1/3 arc-sec)
      DEM = raster("./WetlandData/DEM_NW2/dem_nw2/w001001.adf")
      DEM = reclassify(DEM, 
                        cbind(0, 0.001))
```

###Calculate Topographic Indicies
```{r}
RR = raster(nrow = yROW, ncol = xCOL)
extent(RR) = extent(DEM)

DEM2 = resample(DEM, RR, 
                method='bilinear')

tpi = terrain(DEM2, 
              opt = 'tpi')

TPI = reclassify(tpi, 
                 cbind(NA, minValue(tpi)))

proj4string(TPI) = proj4string(LCLU_NWF.spdf)
extent(TPI) = extent(LCLU_NWF.spdf)

Wetlands.spdf$TPI = values(TPI)
```

```{r}
CTI0 = upslope.area(DEM, 
                    log = TRUE, 
                    atb = TRUE, 
                    deg = 0.1)

CTI = reclassify(CTI0$atb, 
                 cbind(NA, maxValue(CTI0)))

extent(CTI) = extent(LCLU_NWF.spdf)
CTI = resample(CTI, Blank.r, method = 'bilinear')

Wetlands.spdf$CTI = values(CTI)
```

###Verify Significance of TPI and CTI
```{r}
FormTPInw = Designation ~ TPI

TPInw  =  inla(FormTPInw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(TPInw)

FormCTInw = Designation ~ CTI

CTInw  =  inla(FormCTInw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(CTInw)
```

###Initial Evaluation for Collinearity
```{r}
suppressMessages(library(perturb))

Col.df = Wetlands.spdf@data %>%
            select(V1, AWC, OM, SAVI, TPI, CTI) 

CI = colldiag(Col.df)
CI

detach("package:perturb", unload=TRUE)
```

##Bayesian Analysis
###Assign Region and IDs Labels
```{r}
Wetlands.spdf$Region = 1:nrow(Wetlands.spdf)
```

###Spatial Neighborhood as an INLA Graph
```{r}
nb = poly2nb(Wetlands.spdf, queen = FALSE)
nb2INLA("J", nb)
J = inla.read.graph("J")
```

###model0
```{r}
formula0 = Designation ~ f(Region, model = "besag",
                           scale.model = TRUE,
                           adjust.for.con.comp = FALSE, 
                           graph = J) 
                         

model0  =  inla(formula0, family = "binomial",
                control.family = list(link = "cloglog"),
                control.predictor = list(compute = TRUE),
                control.compute = list(cpo = TRUE, waic=TRUE),
                data = Wetlands.spdf@data)

summary(model0)



Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M0SLPM = model0$summary.linear.predictor[,"mean"],
                               M0Prob = exp(M0SLPM)/(1+exp(M0SLPM)))
```


###Plot Spatial Random Effects
```{r}
RE.r = Blank.r
Wetlands.spdf$SREm0 = model0$summary.random$Region[,2]
values(RE.r) = (exp(model0$summary.random$Region$mean/10) - 1) * 100

REffect = round(Wetlands.spdf$SREm0, 4)
Var = rep("RE", length(REffect))
RE.df = data.frame(Var, REffect)
RE.df$REffect = as.numeric(RE.df$REffect)

RE.d = ggplot(RE.df, aes(REffect, fill = as.factor(Var))) + 
              geom_density(fill = "grey") +
              theme_classic() +
              xlim(-25, 25) +
                 xlab("Northwest Florida (model0)") +
                 ylab("Density") +
                 theme(axis.title.y = element_text(size = 15),
                       axis.title.x = element_text(size = 15),
                       plot.title = element_text(size = 20, face="bold")) +
                 geom_vline(data = RE.df, 
                 aes(xintercept = 0,
                     colour = Run),
                     linetype = "dotted",
                     size = 1, col = "red") + 
                ggtitle("Spatial Random Effects")

RE.d 


rng = seq(-70, 120, 19)

rngL = paste(rng, '%', sep = "")
cr = rev(brewer.pal(10, "RdBu"))

M0RE = levelplot(RE.r, margin = FALSE,
          sub = "                Spatial Random Effects (model0)                \n(Above/Below Domain Mean)",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))  

M0RE
```

###model1
```{r}
formula1 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1

model1  =  inla(formula1, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model1)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M1SLPM = model1$summary.linear.predictor[,"mean"],
                               M1Prob = exp(M1SLPM)/(1+exp(M1SLPM)))
```

###model2
```{r}
formula2 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + AWC

model2  =  inla(formula2, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model2)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M2SLPM = model2$summary.linear.predictor[,"mean"],
                               M2Prob = exp(M2SLPM)/(1+exp(M2SLPM)))
```

###model3
```{r}
formula3 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + AWC + OM

model3  =  inla(formula3, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model3)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M3SLPM = model3$summary.linear.predictor[,"mean"],
                               M3Prob = exp(M3SLPM)/(1+exp(M3SLPM)))
```

###model4
```{r}
formula4 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + AWC + OM + SAVI

model4  =  inla(formula4, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model4)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M4SLPM = model4$summary.linear.predictor[,"mean"],
                               M4Prob = exp(M4SLPM)/(1+exp(M4SLPM)))
```

###model5
```{r}
formula5 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + AWC + OM + SAVI + TPI

model5  =  inla(formula5, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model5)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M5SLPM = model5$summary.linear.predictor[,"mean"],
                               M5Prob = exp(M5SLPM)/(1+exp(M5SLPM)))
```

###model6
```{r}
formula6 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + AWC + OM + SAVI + TPI + CTI

model6  =  inla(formula6, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model6)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M6SLPM = model6$summary.linear.predictor[,"mean"],
                               M6Prob = exp(M6SLPM)/(1+exp(M6SLPM)))
```

###model7
```{r}
formula7 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model7  =  inla(formula7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model7)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M7SLPM = model7$summary.linear.predictor[,"mean"],
                               M7Prob = exp(M7SLPM)/(1+exp(M7SLPM)))
```

###model8
```{r}
formula8 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + AWC + OM + SAVI + CTI

model8  =  inla(formula8, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model8)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M8SLPM = model8$summary.linear.predictor[,"mean"],
                               M8Prob = exp(M8SLPM)/(1+exp(M8SLPM)))
```

###model9
```{r}
#No Prior
formula9 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           graph = J) +
                         V1 + AWC + OM + SAVI + TPI

model9  =  inla(formula9, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model9)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M9SLPM = model9$summary.linear.predictor[,"mean"],
                               M9Prob = exp(M9SLPM)/(1+exp(M9SLPM)))
```

###model10
```{r}
#Non-spatial
formula10 = Designation ~ V1 + AWC + OM + SAVI + TPI

model10  =  inla(formula10, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model10)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M10SLPM = model10$summary.linear.predictor[,"mean"],
                               M10Prob = exp(M10SLPM)/(1+exp(M10SLPM)))
```

###Model Selection Tables
Setting-up tables to compare models
```{r}
Models = c("model0", "model1",
           "model2", "model3",
           "model4", "model5",
           "model6" ,"model7",
           "model8", "model9",
           "model10")

Fixed =  c("u (Spatial structure only) ",
           "V1 + u",
           "V1 + AWC + u",
           "V1 + AWC + OM + u",
           "V1 + AWC + OM + SAVI + u",
           "V1 + AWC + OM + SAVI + TPI + u",
           "V1 + AWC + OM + SAVI + TPI + CTI + u",
           "V1 + V2 + V3 + AWC + OM + CTI + TPI + u",
           "V1 + AWC + OM + SAVI + CTI + u",
           "(model5 with no prior specification)",
           "(model5 excluding spatial structure)")

#Watanabe-Akaike information criteria
WAICs = c(model0$waic$waic, model1$waic$waic,
          model2$waic$waic, model3$waic$waic,
          model4$waic$waic, model5$waic$waic,
          model6$waic$waic, model7$waic$waic,
          model8$waic$waic, model9$waic$waic,
          model10$waic$waic)

LCPOs = c(-mean(log(model0$cpo$cpo)), -mean(log(model1$cpo$cpo)),
          -mean(log(model2$cpo$cpo)), -mean(log(model3$cpo$cpo)),
          -mean(log(model4$cpo$cpo)), -mean(log(model5$cpo$cpo)),
          -mean(log(model6$cpo$cpo)), -mean(log(model7$cpo$cpo)),
          -mean(log(model8$cpo$cpo)), -mean(log(model8$cpo$cpo)),
          -mean(log(model10$cpo$cpo)))

#Brier score (looking only at Wetlands - not uplands)
BSs.df = filter(Wetlands.spdf@data, Designation == 1)
BSs = c(mean((BSs.df$M0Prob - 1)^2), mean((BSs.df$M1Prob - 1)^2),
        mean((BSs.df$M2Prob - 1)^2), mean((BSs.df$M3Prob - 1)^2),
        mean((BSs.df$M4Prob - 1)^2), mean((BSs.df$M5Prob - 1)^2),
        mean((BSs.df$M6Prob - 1)^2), mean((BSs.df$M7Prob - 1)^2),
        mean((BSs.df$M8Prob - 1)^2), mean((BSs.df$M9Prob - 1)^2),
        mean((BSs.df$M10Prob - 1)^2))

Model_mets = as.data.frame(cbind(MODEL = Models,
                                 WAIC = round(WAICs, 2),
                                 LCPO = round(LCPOs, 3),
                                 BS = round(BSs, 3),
                                 COVARIATES = Fixed))
```

###Select Model
Watanabe-Akaike information criterion (WAIC) and Brier Score (BS) for all model are compared below.
```{r}
print.data.frame(Model_mets, right = FALSE)

print.data.frame(model7$summary.fixed)

#Exponentiate
FIX(model7)

#library(xtable)
#Table2 = xtable(Model_mets)
#print(Table2, include.rownames = FALSE)

#M7.df = as.data.frame(model7$summary.fixed)
#colnames(M7.df) = c("Mean", "sd", "Quant0.025", "Quant0.5", "Quant0.975", "mode", "kld")
#M7b.df = M7.df %>%
#            select(Mean, Quant0.025, Quant0.5, Quant0.975)

#Mod7Table = xtable(M7b.df, 
#                   caption = "Summary of Fixed Values (model7)", 
#                  digits=c(0,4,4,4,4))
#print(Mod7Table, 
#     include.rownames = TRUE, 
 #     floating = TRUE )

M7_NW = model7
```

###Plot Random Effects
```{r}
RE1.r = Blank.r
Wetlands.spdf$SREm7 = model7$summary.random$Region[,2]
values(RE1.r) = (exp(model7$summary.random$Region$mean/10) - 1) * 100

REffect = round(Wetlands.spdf$SREm7, 4)
Var = rep("RE", length(REffect))
RE.df = data.frame(Var, REffect)
RE.df$REffect = as.numeric(RE.df$REffect)

RE.d = ggplot(RE.df, aes(REffect, fill = as.factor(Var))) + 
              geom_density(fill = "grey") +
              theme_classic() +
              xlim(-25, 25) +
                 xlab("Northwest Florida (model7)") +
                 ylab("Density") +
                 theme(axis.title.y = element_text(size = 15),
                       axis.title.x = element_text(size = 15),
                       plot.title = element_text(size = 20, face="bold")) +
                 geom_vline(data = RE.df, 
                 aes(xintercept = 0,
                     colour = Run),
                     linetype = "dotted",
                     size = 1, col = "red") + 
                ggtitle("Spatial Random Effects")

RE.d 


rng = seq(-70, 120, 19)

rngL = paste(rng, '%', sep = "")
cr = rev(brewer.pal(10, "RdBu"))

M5RE = levelplot(RE1.r, margin = FALSE,
          sub = "                Spatial Random Effects (model7)                \n(Above/Below Domain Mean)",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))  

M5RE
```

###Wetland Probabilty Map
```{r}
M7NW = Blank.r
values(M7NW) = Wetlands.spdf@data$M7Prob

rng = seq(0, 1, 0.10)
rngL = paste(rng*100, '%', sep = "")
cr = brewer.pal(10, "BrBG")
M7NW.r = levelplot(M7NW, margin = FALSE, 
          sub = "Probabilty of Wetland Presence             ",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))

M7NW.r

NW_Mwcnt.df = filter(Wetlands.spdf@data, M7Prob >= 0.5)
NW_M7cnt = length(NW_Mwcnt.df$M7Prob)
```

####Write Raster to File
```{r}
#Final_Raster = writeRaster(M2p, filename ="./WetlandData/WetlandPrediction.tif", overwrite=TRUE)
```

```{r}
rm(list=setdiff(ls(), c("FIX", "model7", "model7_30", "model7_70", "model7_200", "M7_NW",
                        "model7_300", "Brier", "M7NW", "SDAquery", "NW_M7cnt")))
```






Study Area Domain SW
---------------------
```{r}
Map = get_map(location = c(-81.80, 27.55), 
              source = "google",
              zoom = 12,
              color = "color",
              maptype = "terrain")
p1 = ggmap(Map, dev = "extent") +
  geom_segment(aes(x = -81.846, xend = -81.74436  , y = 27.60774, yend = 27.60774 ), 
             color = "red") +
  geom_segment(aes(x = -81.846, xend = -81.74436  , y = 27.51743, yend = 27.51743), 
             color = "red") +
  geom_segment(aes(x = -81.846, xend = -81.846, y = 27.60774, yend = 27.51743), 
             color = "red") +
  geom_segment(aes(x = -81.74436, xend = -81.74436, y = 27.60774, yend = 27.51743), 
             color = "red") + 
  labs(x = expression(paste("Longitude (", degree, "W)")), 
       y = expression(paste("Latitude (", degree, "N)")))

source('./WetlandData/ScaleBar/ScaleBarNorth.R')

p1b = p1 + scaleBar(lon = -81.90,
                    lat = 27.455,
                    distanceLon = 5,
                    distanceLat = 1,
                    distanceLegend = 1.5,
                    dist.unit = "km",
                    arrow.length = 3,
                    arrow.distance = 2,
                    arrow.North.size = 12)

p1b + theme(panel.grid.minor = element_line(colour = NA), 
            panel.grid.minor = element_line(colour = NA),
            panel.background = element_rect(fill = NA, colour = NA), 
            rect = element_blank())
```

```{r}
graphics.off()
```

###Domain Target Cell Size (TCS) 
```{r}
TCS = 50 #Raster cell edge length (meters)

xCOL = ceiling(10000/TCS)
yROW = ceiling(10000/TCS)
```

###Read Soil and Landuse/Landcover Shapefiles
```{r}
#Soils Data
    Raw_Soils.spdf = readOGR(dsn = "./WetlandData/SSURGO_SWF", layer = "SSURGO_SWF", 
                     stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                     gIsValid(Raw_Soils.spdf) #Chk TopologY
                     Raw_Soils.spdf = gBuffer(Raw_Soils.spdf, width=0, byid=TRUE) #Fix Topology

#Landcover/Landuse Data
    LCLU_NWF.spdf = readOGR(dsn = "./WetlandData/LCLU_SWF", layer = "LCLU_SWF", 
                    stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
                    gIsValid(LCLU_NWF.spdf)
                    LCLU_NWF.spdf = gBuffer(LCLU_NWF.spdf, width=0, byid=TRUE)   
```

###Subset Landcover Groups
```{r}    
UP_LC.spdf = subset(LCLU_NWF.spdf, 
                    FLUCCSCODE >= 2600 & 
                    FLUCCSCODE <= 4430 )

Wet_LC.spdf = subset(LCLU_NWF.spdf, 
                     FLUCCSCODE >= 5000 & 
                     FLUCCSCODE <= 6999 )
```

###Crop soils data
```{r}
UP_Soils.spdf = crop(Raw_Soils.spdf, UP_LC.spdf) 
UP_Soils.spdf@data = UP_Soils.spdf@data %>%
                     mutate(Designation = 0)


Wet_Soils.spdf = crop(Raw_Soils.spdf, Wet_LC.spdf)
Wet_Soils.spdf@data = Wet_Soils.spdf@data %>%
                      mutate(Designation = 1)
```

```{r}
UP_Soils1.spdf = spChFIDs(UP_Soils.spdf, 
                          paste(as.character(
                                1:nrow(UP_Soils.spdf)),"U", sep = ""))

Wet_Soils1.spdf = spChFIDs(Wet_Soils.spdf, 
                           paste(as.character(
                                1:nrow(Wet_Soils.spdf)),"W", sep = ""))

Soils.spdf = spRbind(UP_Soils1.spdf, Wet_Soils1.spdf)

Soils.spdf$IDs = 1:nrow(Soils.spdf)
```

###Prior Distribution
```{r}
D0 = 0.33 #Prob of wetlands in Florida
D1 = 0.50 #Prop of being wetland if known to have wetland vegetation

Soils.spdf$Extent = gArea(Soils.spdf,
                          byid = TRUE)

Wet_area = as.numeric(
             Soils.spdf@data %>%
                       filter(Designation == 1) %>%
                       summarise(sum(Extent, na.rm = TRUE)))

Up_area = as.numeric(
            Soils.spdf@data %>%
                      filter(Designation == 0) %>%
                      summarise(sum(Extent, na.rm = TRUE)))

Wp = (Wet_area/(Wet_area + Up_area))
Up = (Up_area/(Wet_area + Up_area))

Pr = (Up*D0) + (Wp*D1)

q1 = list(p = .5, x = Pr)
q2 = list(p = .9, x = D1)
B.select = beta.select(q1, q2) 

a = B.select[1]
b = B.select[2]
```

```{r}
hyper.p = list(prec = list(
                        list(prior = "logitbeta", 
                             param = c(a, b),
                             initial = 0)))
```

###Combine Upland and Wetland Data Frames
```{r}
Soils.df = Soils.spdf@data

Soils0.df = subset(Soils.df, 
                   select = -c(AREASYMBOL,  SPATIALVER, NationalMu,  
                                muhelcl,  muwathelcl,  muwndhelcl,  interpfocu, 
                                invesinten,  lkey,  iacornsr,  projectsca,  tabularver, 
                                iccdcd,   iccdcdpct,  engstafdcd,  engstafll,  engstafml, 
                                albedo_h,  albedo_l,  cropprodin,  rsprod_h,  rsprod_l, 
                                rsprod_r,  slopelen_h,  slopelen_l,  cokey,  comppct_l,   
                                comppct_h,  compkind,  earthcovki,  earthcov_1,  aspectccwi, 
                                aspectrep,  aspectcwis,  geomdesc,  nirrcapuni,  irrcapcl, 
                                irrcapscl,  irrcapunit,  constreesh,  soilslippo,  frostact, 
                                soiltaxedi,  taxclname,  taxorder,  taxsuborde,  taxgrtgrou, 
                                taxsubgrp,  taxparts_1, map_h,  map_l,	map_r, Shape_Leng, Shape_Area))

Soils1.df = as.data.frame(lapply
                          (Soils0.df, factor))
Soils2.df = Soils1.df %>%
            mutate(Designation = as.numeric(Soils.df$Designation),
                   IDs = as.numeric(Soils.df$IDs),
                   wtdepaprju = as.numeric(round(Soils.df$wtdepaprju),5),
                   wtdepannmi = as.numeric(round(Soils.df$wtdepannmi),5),
                   slopegradd = as.numeric(round(Soils.df$slopegradd),5),
                   slopegradw = as.numeric(round(Soils.df$slopegradw), 5),
                   aws025wta = as.numeric(round(Soils.df$aws025wta), 5),
                   aws050wta = as.numeric(round(Soils.df$aws050wta), 5),
                   aws0100wta = as.numeric(round(Soils.df$aws0100wta), 5),
                   aws0150wta = as.numeric(round(Soils.df$aws0150wta), 5),
                   niccdcdpct = as.numeric(round(Soils.df$niccdcdpct), 5),
                   albedo_r = as.numeric(round(Soils.df$albedo_r), 5),
                   elev_h = as.numeric(round(Soils.df$elev_h), 5),
                   elev_l = as.numeric(round(Soils.df$elev_l), 5),
                   elev_r = as.numeric(round(Soils.df$elev_r), 5),
                   slope_h = as.numeric(round(Soils.df$slope_h), 5),
                   slope_r = as.numeric(round(Soils.df$niccdcdpct), 5))
```

###Conduct Principal Components Analysis (PCA)
``` {r}
Soils.PCA = Soils2.df %>%
                select(slopegradd, slopegradw, aws025wta, aws050wta, aws0100wta,
                aws0150wta, niccdcdpct, albedo_r, elev_h, elev_l, elev_r, slope_h, 
                slope_r, wtdepaprju, wtdepannmi)

PCA.Result = PCA(Soils.PCA , 
                 scale.unit = TRUE, 
                 ncp = 5, 
                 graph = FALSE)
```

##Singular Value Decomposition (SVD) to Data Frame
```{r}
PCA.df = as.data.frame(PCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```
 
###Verify Significance of PCA
```{r}
PCAfsw = Designation ~ V1 + V2 + V3 + V4 + V5

PCAsw  =  inla(PCAfsw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = PCA.df)
summary(PCAsw)

PCAfsw2 = Designation ~ V1 + V4

PCAsw2  =  inla(PCAfsw2, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = PCA.df)
summary(PCAsw2)
```

###Conduct Multiple Correspondance Analysis (MCA)
``` {r}
Soils.MCA = Soils2.df %>%
               select(MUSYM, muname, mukind, farmlndcl, museq, brockdepmi, 
                      flodfreqdc, flodfreqma, pondfreqpr, drclassdcd, 
                      drclasswet, hydgrpdcd, niccdcd, engdwobdcd, engdwbdcd,  engdwbll,  
                      engdwbml,   engsldcd,   engsldcp, englrsdcd,  engcmssdcd, engcmssmp, 
                      urbrecptdc, urbrecptwt, forpehrtdc, hydclprs, awmmfpwwta, airtempa_h, 
                      airtempa_l, airtempa_r, ffd_h, ffd_l, ffd_r, initsub_h, initsub_l, 
                      initsub_r, slope_l, slopelen_r, totalsub_h, totalsub_l, totalsub_r, 
                      compname, otherph, localphase, runoff, tfact, wei, weg, erocl, 
                      hydricon, nirrcapcl, nirrcapscl, foragesuit, wlgrai, wlgrass, wlherbaceo,
                      wlshrub, wlconifero, wlhardwood, wlwetplant, wlshalloww, wlrangelan, 
                      wlopenland, wlwoodland, wlwetland, corcon, corsteel, taxpartsiz, 
                      taxceactcl, taxreactio, taxtempcl, taxmoistsc, taxtempreg)

MCA.Result = MCA(Soils.MCA, 
                 ncp=5, 
                 graph = FALSE)
```

###MCA Singular Value Decomposition (SVD) to .df
```{r}
MCA.df = as.data.frame(MCA.Result$svd$U) %>%
                 mutate(Designation = as.numeric(Soils.df$Designation))
```

###Verify Significance of MCA
```{r}
MCAfsw = Designation ~ V1 + V2 + V3 + V4 + V5

MCAsw  =  inla(MCAfsw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = MCA.df)
summary(MCAsw)

MCAfswb = Designation ~ V2 + V3

MCAswb  =  inla(MCAfswb, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = MCA.df)
summary(MCAswb)
```

###Combine Significant MCA and PCA Results
```{r}
Soils2.spdf = Soils.spdf

Soils2.spdf@data = PCA.df %>%
                   select(Designation, V1, V2, V3, V4) %>%
                   mutate(MCAV2 = MCA.df[,"V2"],
                          MCAV3 = MCA.df[,"V3"],
                          MUKEY = as.numeric(Soils.spdf@data[,"MUKEY"]))
```

###Convert Soils PCA and MCA Results to Raster Objects
```{r}
Blank.r = raster(nrows = yROW, ncols = xCOL)
extent(Blank.r) = extent(Soils2.spdf)
proj4string(Blank.r) = proj4string(Soils2.spdf)
```

###Create Wetland/Upland Designation Raster
```{r}
w_rast = rasterize(Wet_Soils.spdf,
                   Blank.r,
                   field = 1)

w_rast = reclassify(w_rast,
                    cbind(NA, 0))
```

###Create Rasters for Significatnt PCA/MCA Results
```{r}
V1_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V1)

V2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V2)

V3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V3)

V4_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$V4)

MCA2_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$MCAV2)

MCA3_rast = rasterize(Soils2.spdf,
                    Blank.r,
                    field = Soils2.spdf@data$MCAV3)
```

###Convert Rasters to SpatialPolygonsDataFrame
```{r}
Wetlands.spdf = as(w_rast, "SpatialPolygonsDataFrame")
names(Wetlands.spdf) = "Designation"

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(V1 = values(V1_rast),
                               V2 = values(V2_rast),
                               V3 = values(V3_rast),
                               V4 = values(V4_rast),
                               MCAV2 = values(MCA2_rast),
                               MCAV3 = values(MCA3_rast))
```

##Soil Available Water Capacity (AWC) and Organic Mass (OM)
###Rasterize MUKEY 
```{r}
AWC.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)

OM.r = rasterize(Soils2.spdf,
                      Blank.r,
                      field = Soils2.spdf@data$MUKEY)
```

###Soil Functions
```{r}
HzWS = function(i) {
              wt = i$comppct_r[1]  
              thick = with(i, hzdepb_r - hzdept_r)  
              whc = thick * i$awc_r 
            	whc.total = sum(whc, na.rm=TRUE)  
	            data.frame(whc = whc.total, wt=wt)  
}

HzWSO = function(i) {
              wto = i$comppct_r[1]  
              thicko = with(i, hzdepb_r - hzdept_r)  
              whco = thicko * i$Om_r  
            	whc.totalo = sum(whco, na.rm=TRUE)   
	            data.frame(whco = whc.totalo, wto=wto)  
}
```

```{r}
MU_mean = function(i) {
	              whc = wtd.mean(i$whc, weights=i$wt)  
	              data.frame(whc=whc)  
}

MU_meano = function(i) {
	              whco = wtd.mean(i$whco, weights=i$wto)  
	              data.frame(whco=whco)  
}
```

###Add Raster Attribute Table (RAT)
```{r}
AWC.r = ratify(AWC.r,
               count = TRUE)

OM.r = ratify(OM.r,
               count = TRUE)
```

###save RATs as Objects
```{r}
rat = levels(AWC.r)[[1]]

rato = levels(OM.r)[[1]]
```

###Extract MUKEYs from the RAT
```{r}
in.statement = format_SQL_in_statement(rat$ID)

in.statement2 = format_SQL_in_statement(rato$ID)
```

###Query SDA
```{r}
q = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

ACW.res = SDAquery(q) 
```

```{r}
q2 = paste("SELECT component.mukey, component.cokey, compname, comppct_r, hzdept_r, hzdepb_r, hzname, Om_r, awc_r FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2, "ORDER BY mukey, comppct_r DESC, hzdept_r ASC", sep ="")

OM.res = SDAquery(q2) 
```

###Aggregate Data
```{r}
co.whc = ACW.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWS(.))

mu.whc = co.whc %>% 
              group_by(mukey) %>% 
              do(MU_mean(.))

co.whco = OM.res %>% 
              group_by(mukey, cokey) %>% 
              do(HzWSO(.))

mu.whco = co.whco %>% 
              group_by(mukey) %>% 
              do(MU_meano(.))
```

###Join Results to Domain Rasters
```{r}
names(mu.whc)[1] = 'ID'
rat.new = left_join(rat, mu.whc)
levels(AWC.r) = rat.new
AWC = deratify(AWC.r, att='whc')

names(mu.whco)[1] = 'ID'
rato.new = left_join(rato, mu.whco)
levels(OM.r) = rato.new
OM = deratify(OM.r, att='whco')
```

###Add Results to Wetlands.spdf
```{r}
Wetlands.spdf$AWC = values(AWC)
Wetlands.spdf$OM = values(OM)
```

###Verify Significance of AWC and OM
```{r}
AWCfsw = Designation ~ AWC

AWCsw  =  inla(AWCfsw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(AWCsw)


OMfsw = Designation ~ OM

OMsw  =  inla(OMfsw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(OMsw)
```

###Soil Adjusted Vegetation Index (SAVI)
```{r}
Band4 = raster("./WetlandData/LS8_sw/ls8_band4sw/w001001.adf")

Band5 = raster("./WetlandData/LS8_sw/ls8_band5sw/w001001.adf")
      
savi = ((Band5 - Band4) / (Band5 + Band4 + 0.5)) * (1.5)

extent(savi) = extent(Blank.r)

SAVI = resample(savi, Blank.r, 
                method = 'bilinear')

Wetlands.spdf$SAVI = values(SAVI)
```

###Verify Significance of SAVI
```{r}
Form5sw = Designation ~ SAVI

SAVIsw  =  inla(Form5sw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(SAVIsw)
```

###Explanatory Variables linked to Topograpy 
```{r}
#DEM (USGS 1/3 arc-sec)
      DEM = raster("./WetlandData/DEM_SWF/dem_swf/w001001.adf")
      DEM = reclassify(DEM, 
                        cbind(0, 0.001))
      
```

###Calculate Topographic Indicies
```{r}
RR = raster(nrow = yROW, ncol = xCOL)
extent(RR) = extent(DEM)

DEM2 = resample(DEM, RR, 
                method='bilinear')

tpi = terrain(DEM2, 
              opt = 'tpi')

TPI = reclassify(tpi, 
                 cbind(NA, minValue(tpi)))

extent(TPI) = extent(Blank.r)

Wetlands.spdf$TPI = values(TPI)
```

```{r}
CTI0 = upslope.area(DEM, 
                    log = TRUE, 
                    atb = TRUE, 
                    deg = 0.1)

CTI = reclassify(CTI0$atb, 
                 cbind(NA, maxValue(CTI0)))

extent(CTI) = extent(Blank.r)
CTI = resample(CTI, Blank.r, method = 'bilinear')

Wetlands.spdf$CTI = values(CTI)
```

###Verify Significance of TPI and CTI
```{r}
FormTPIsw = Designation ~ TPI

TPIsw  =  inla(FormTPIsw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(TPIsw)

FormCTIsw = Designation ~ CTI

CTIsw  =  inla(FormCTIsw, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(dic = TRUE, cpo = TRUE),
                       data = Wetlands.spdf@data)
summary(CTIsw)
```

###Initial Evaluation for Collinearity
```{r}
suppressMessages(library(perturb))

Col.df = Wetlands.spdf@data %>%
            select(V1, V4, MCAV2, MCAV3, AWC, OM, SAVI, TPI, CTI) 

CI = colldiag(Col.df)
CI

detach("package:perturb", unload=TRUE)
```

#Bayesian Analysis
###Assign Region and IDs Labels
```{r}
Wetlands.spdf$Region = 1:nrow(Wetlands.spdf)
```

###Spatial Neighborhood as an INLA Graph
```{r}
nb = poly2nb(Wetlands.spdf, queen = FALSE)
nb2INLA("J", nb)
J = inla.read.graph("J")
```

###model0
```{r}
formula0 = Designation ~ f(Region, model = "besag",
                           scale.model = TRUE,
                           adjust.for.con.comp = FALSE, 
                           graph = J) 
                         

model0  =  inla(formula0, family = "binomial",
                control.family = list(link = "cloglog"),
                control.predictor = list(compute = TRUE),
                control.compute = list(cpo = TRUE, waic=TRUE),
                data = Wetlands.spdf@data)

summary(model0)



Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M0SLPM = model0$summary.linear.predictor[,"mean"],
                               M0Prob = exp(M0SLPM)/(1+exp(M0SLPM)))
```

###Plot Random Effects
```{r}
RE.r = Blank.r
Wetlands.spdf$SREm0 = model0$summary.random$Region[,2]
values(RE.r) = (exp(model0$summary.random$Region$mean/10) - 1) * 100

REffect = round(Wetlands.spdf$SREm0, 4)
Var = rep("RE", length(REffect))
RE.df = data.frame(Var, REffect)
RE.df$REffect = as.numeric(RE.df$REffect)

RE.d = ggplot(RE.df, aes(REffect, fill = as.factor(Var))) + 
              geom_density(fill = "grey") +
              theme_classic() +
              xlim(-25, 25) +
                 xlab("Southwest Florida (model0)") +
                 ylab("Density") +
                 theme(axis.title.y = element_text(size = 15),
                       axis.title.x = element_text(size = 15),
                       plot.title = element_text(size = 20, face="bold")) +
                 geom_vline(data = RE.df, 
                 aes(xintercept = 0,
                     colour = Run),
                     linetype = "dotted",
                     size = 1, col = "red") + 
                ggtitle("Spatial Random Effects")

RE.d 


rng = seq(-50, 150, 20)

rngL = paste(rng, '%', sep = "")
cr = rev(brewer.pal(10, "RdBu"))

M0RE = levelplot(RE.r, margin = FALSE,
          sub = "                Spatial Random Effects (model0)                \n(Above/Below Domain Mean)",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))  

M0RE
```

###model1
```{r}
formula1 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1

model1  =  inla(formula1, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model1)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M1SLPM = model1$summary.linear.predictor[,"mean"],
                               M1Prob = exp(M1SLPM)/(1+exp(M1SLPM)))
```

###model2
```{r}
formula2 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4

model2  =  inla(formula2, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model2)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M2SLPM = model2$summary.linear.predictor[,"mean"],
                               M2Prob = exp(M2SLPM)/(1+exp(M2SLPM)))
```

###model3
```{r}
formula3 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2

model3  =  inla(formula3, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model3)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M3SLPM = model3$summary.linear.predictor[,"mean"],
                               M3Prob = exp(M3SLPM)/(1+exp(M3SLPM)))
```

###model4
```{r}
formula4 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3

model4  =  inla(formula4, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model4)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M4SLPM = model4$summary.linear.predictor[,"mean"],
                               M4Prob = exp(M4SLPM)/(1+exp(M4SLPM)))
```

###model5
```{r}
formula5 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC

model5  =  inla(formula5, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model5)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M5SLPM = model5$summary.linear.predictor[,"mean"],
                               M5Prob = exp(M5SLPM)/(1+exp(M5SLPM)))
```

###model6
```{r}
formula6 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + OM

model6  =  inla(formula6, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model6)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M6SLPM = model6$summary.linear.predictor[,"mean"],
                               M6Prob = exp(M6SLPM)/(1+exp(M6SLPM)))
```

###model7
```{r}
formula7 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + OM + SAVI

model7  =  inla(formula7, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model7)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M7SLPM = model7$summary.linear.predictor[,"mean"],
                               M7Prob = exp(M7SLPM)/(1+exp(M7SLPM)))
```

###model8
```{r}
formula8 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + OM + SAVI + TPI

model8  =  inla(formula8, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model8)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M8SLPM = model8$summary.linear.predictor[,"mean"],
                               M8Prob = exp(M8SLPM)/(1+exp(M8SLPM)))
```

###model9
```{r}
formula9 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + OM + SAVI + TPI + CTI

model9  =  inla(formula9, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model9)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M9SLPM = model9$summary.linear.predictor[,"mean"],
                               M9Prob = exp(M9SLPM)/(1+exp(M9SLPM)))
```

###model10
```{r}
formula10 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + TPI + CTI

model10  =  inla(formula10, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model10)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M10SLPM = model10$summary.linear.predictor[,"mean"],
                               M10Prob = exp(M10SLPM)/(1+exp(M10SLPM)))
```

###model11
```{r}
formula11 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + CTI

model11  =  inla(formula11, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model11)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M11SLPM = model11$summary.linear.predictor[,"mean"],
                               M11Prob = exp(M11SLPM)/(1+exp(M11SLPM)))
```

###model12
```{r}
formula12 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + TPI

model12  =  inla(formula12, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model12)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M12SLPM = model12$summary.linear.predictor[,"mean"],
                               M12Prob = exp(M12SLPM)/(1+exp(M12SLPM)))
```

###model13
```{r}
formula13 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI

model13  =  inla(formula13, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model13)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M13SLPM = model13$summary.linear.predictor[,"mean"],
                               M13Prob = exp(M13SLPM)/(1+exp(M13SLPM)))
```

###model14
```{r}
#Non-spatial
formula14 = Designation ~ V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + TPI + CTI

model14  =  inla(formula14, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model14)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M14SLPM = model14$summary.linear.predictor[,"mean"],
                               M14Prob = exp(M14SLPM)/(1+exp(M14SLPM)))
```

###model15
```{r}
#No prior
formula15 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           graph = J) +
                         V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + TPI + CTI

model15  =  inla(formula15, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model15)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M15SLPM = model15$summary.linear.predictor[,"mean"],
                               M15Prob = exp(M15SLPM)/(1+exp(M15SLPM)))
```

###model16
```{r}
formula16 = Designation ~ f(Region, model = "besag", 
                           adjust.for.con.comp = FALSE, 
                           scale.model = TRUE,
                           hyper = hyper.p,
                           graph = J) +
                         V1 + V2 + V3 + AWC + OM + CTI + TPI

model16  =  inla(formula16, family = "binomial",
                       control.family = list(link = "cloglog"),
                       control.predictor = list(compute = TRUE),
                       control.compute=list(cpo = TRUE, waic=TRUE),
                       data = Wetlands.spdf@data)

summary(model16)

Wetlands.spdf@data = Wetlands.spdf@data %>%
                        mutate(M16SLPM = model16$summary.linear.predictor[,"mean"],
                               M16Prob = exp(M16SLPM)/(1+exp(M16SLPM)))
```

###Model Selection Tables
Setting-up tables to compare models
```{r}
Models = c("model0", "model1",
           "model2", "model3",
           "model4", "model5",
           "model6" ,"model7",
           "model8", "model9",
           "model10", "model11",
           "model12", "model13",
           "model14", "model15",
           "model16")

Fixed =  c("u (Spatial structure only) ",
           "V1 + u",
           "V1 + V4 + u",
           "V1 + V4 + MCAV2 + u",
           "V1 + V4 + MCAV2 + MCAV3 + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + OM + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + OM + SAVI + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + OM + SAVI + TPI + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + OM + SAVI + TPI + CTI + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + TPI + CTI + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + CTI + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + TPI + u",
           "V1 + V4 + MCAV2 + MCAV3 + AWC + SAVI + u",
           "(model10 with no prior specification)",
           "(model10 excluding spatial structure)",
           "(Primary Domain) V1 + V2 + V3 + AWC + OM + CTI + TPI + u")

#Watanabe-Akaike information criteria
WAICs = c(model0$waic$waic, model1$waic$waic,
          model2$waic$waic, model3$waic$waic,
          model4$waic$waic, model5$waic$waic,
          model6$waic$waic, model7$waic$waic,
          model8$waic$waic, model9$waic$waic,
          model10$waic$waic, model11$waic$waic,
          model12$waic$waic, model13$waic$waic,
          model14$waic$waic, model15$waic$waic,
          model16$waic$waic)

LCPOs = c(-mean(log(model0$cpo$cpo)), -mean(log(model1$cpo$cpo)),
          -mean(log(model2$cpo$cpo)), -mean(log(model3$cpo$cpo)),
          -mean(log(model4$cpo$cpo)), -mean(log(model5$cpo$cpo)),
          -mean(log(model6$cpo$cpo)), -mean(log(model7$cpo$cpo)),
          -mean(log(model8$cpo$cpo)), -mean(log(model9$cpo$cpo)),
          -mean(log(model10$cpo$cpo)), -mean(log(model11$cpo$cpo)),
          -mean(log(model12$cpo$cpo)), -mean(log(model13$cpo$cpo)),
          -mean(log(model14$cpo$cpo)), -mean(log(model15$cpo$cpo)),
          -mean(log(model16$cpo$cpo)))

#Brier score (looking only at Wetlands - not uplands)
BSs.df = filter(Wetlands.spdf@data, Designation == 1)
BSs = c(mean((BSs.df$M0Prob - 1)^2), mean((BSs.df$M1Prob - 1)^2),
        mean((BSs.df$M2Prob - 1)^2), mean((BSs.df$M3Prob - 1)^2),
        mean((BSs.df$M4Prob - 1)^2), mean((BSs.df$M5Prob - 1)^2),
        mean((BSs.df$M6Prob - 1)^2), mean((BSs.df$M7Prob - 1)^2),
        mean((BSs.df$M8Prob - 1)^2), mean((BSs.df$M9Prob - 1)^2),
        mean((BSs.df$M10Prob - 1)^2), mean((BSs.df$M11Prob - 1)^2),
        mean((BSs.df$M12Prob - 1)^2), mean((BSs.df$M13Prob - 1)^2),
        mean((BSs.df$M14Prob - 1)^2), mean((BSs.df$M15Prob - 1)^2),
        mean((BSs.df$M16Prob - 1)^2))

Model_mets = as.data.frame(cbind(MODEL = Models,
                                 WAIC = round(WAICs, 2),
                                 LCPO = round(LCPOs, 3),
                                 BS = round(BSs, 3),
                                 COVARIATES = Fixed))
```

###Select Model
Watanabe-Akaike information criterion (WAIC) and Brier Score (BS) for all model are compared below.
```{r}
print.data.frame(Model_mets, right = FALSE)

print.data.frame(model16$summary.fixed)

#Exponentiate
FIX(model16)

#library(xtable)
#Table2 = xtable(Model_mets)
#print(Table2, include.rownames = FALSE)

#M16.df = as.data.frame(model16$summary.fixed)
#colnames(M16.df) = c("Mean", "sd", "Quant0.025", "Quant0.5", "Quant0.975", "mode", "kld")
#M16b.df = M16.df %>%
#            select(Mean, Quant0.025, Quant0.5, Quant0.975)

#Mod16Table = xtable(M16b.df, 
#                   caption = "Summary of Fixed Values (model16)", 
#                  digits=c(0,4,4,4,4))
#print(Mod16Table, 
#     include.rownames = TRUE, 
 #     floating = TRUE )

M16_SW = model16
```

###Second Evaluation for Collinearity
Check models for possible collinearity
```{r}
suppressMessages(library(perturb))

Col_M16.df = Wetlands.spdf@data %>%
            select(V1, V2, V3, MCAV3, AWC, SAVI, TPI, CTI) 

M16_col = colldiag(Col_M16.df)
M16_col

detach("package:perturb", unload=TRUE)
```

###Plot Random Effects 
```{r}
RE1.r = Blank.r
Wetlands.spdf$SREm16 = model16$summary.random$Region[,2]
values(RE1.r) = (exp(model6$summary.random$Region$mean/10) - 1) * 100

REffect = round(Wetlands.spdf$SREm16, 4)
Var = rep("RE", length(REffect))
RE.df = data.frame(Var, REffect)
RE.df$REffect = as.numeric(RE.df$REffect)

RE.d = ggplot(RE.df, aes(REffect, fill = as.factor(Var))) + 
              geom_density(fill = "grey") +
              theme_classic() +
              xlim(-25, 25) +
                 xlab("Southwest Florida (model16)") +
                 ylab("Density") +
                 theme(axis.title.y = element_text(size = 15),
                       axis.title.x = element_text(size = 15),
                       plot.title = element_text(size = 20, face="bold")) +
                 geom_vline(data = RE.df, 
                 aes(xintercept = 0,
                     colour = Run),
                     linetype = "dotted",
                     size = 1, col = "red") + 
                ggtitle("Spatial Random Effects")

RE.d 


rng = seq(-50, 150, 20)

rngL = paste(rng, '%', sep = "")
cr = rev(brewer.pal(10, "RdBu"))

M0RE = levelplot(RE1.r, margin = FALSE,
          sub = "                Spatial Random Effects (model16)                \n(Above/Below Domain Mean)",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))  

M0RE
```

###Wetland Probabilty Map
```{r}
MSW = Blank.r
values(MSW) = Wetlands.spdf@data$M16Prob

rng = seq(0, 1, 0.10)
rngL = paste(rng*100, '%', sep = "")
cr = brewer.pal(10, "BrBG")
M7NW.r = levelplot(MSW, margin = FALSE, 
          sub = "Probabilty of Wetland Presence             ",
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(at = rng, labels = rngL, col = cr),
          par.settings = list(fontsize = list(text = 13)))

M7NW.r
```

###Compare NW and SW Domains to NWI
```{r}
NWI_NW = readOGR(dsn = "./WetlandData/NWI/DomainNW2", 
              layer = "NWI_NW2", 
              stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
              gIsValid(NWI_NW)
              NWI = gBuffer(NWI_NW, width=0, byid=TRUE)
NW.r = M7NW
nwi.NW = rasterize(NWI_NW,
                   NW.r,
                   field = 1)
                    
nwi.NW = reclassify(nwi.NW, 
                     cbind(NA, 0))

Wetlands.spdf$NWInw = values(nwi.NW)

nwi2.NW = reclassify(nwi.NW, 
                     cbind(1, NA))

Wet_ChangeNW = sum(nwi2.NW, M7NW)
stackNW = stack(M7NW, nwi.NW, Wet_ChangeNW)
names(stackNW) = c("Model", "NWI", "Compare")

rng = seq(0, 1, 0.1)
rngL = paste(rng*100, '%', sep = "")
cr = rev(topo.colors(10))
levelplot(stackNW, 
          layout=c(3, 1),
          margin = FALSE, 
          sub = NULL,
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(space = "bottom", 
                          at = rng, 
                          labels = rngL, 
                          col = cr),
          par.settings = list(fontsize = list(text = 13)))


#SW
NWI_SW = readOGR(dsn = "./WetlandData/NWI/DomainSW", 
              layer = "NWI_SW", 
              stringsAsFactors = FALSE, p4s = "+proj=utm +zone=17 +datum=NAD83")
              gIsValid(NWI_SW)
              NWI = gBuffer(NWI_SW, width=0, byid=TRUE)
              
nwi.SW = rasterize(NWI_SW,
                   Blank.r,
                   field = 1)
                    
nwi.SW = reclassify(nwi.SW, 
                     cbind(NA, 0))

Wetlands.spdf$NWIsw = values(nwi.SW)

nwi2.SW = reclassify(nwi.SW, 
                     cbind(1, NA))

M16SW = Blank.r
values(M16SW) = Wetlands.spdf@data$M16Prob

Wet_ChangeSW = sum(nwi2.SW, M16SW)

stackSW = stack(M16SW, nwi.SW, Wet_ChangeSW)
names(stackSW) = c("Model", "NWI", "Compare")

rng = seq(0, 1, 0.1)
rngL = paste(rng*100, '%', sep = "")
cr = rev(topo.colors(10))
levelplot(stackSW, 
          layout=c(3, 1),
          margin = FALSE, 
          sub = NULL,
          xlab = NULL, ylab = NULL, 
          col.regions = cr, at = rng,
          colorkey = list(space = "bottom", 
                          at = rng, 
                          labels = rngL, 
                          col = cr),
          par.settings = list(fontsize = list(text = 13)))
```

###Compare models to NWI
```{r}
Models = c("model0", "model1",
           "model2", "model3",
           "model4", "model5",
           "model6" ,"model7",
           "model8", "model9",
           "model10", "model11",
           "model12", "model13",
           "model14", "model15",
           "model16")

#Brier score (looking only at NWI)
BSNWI.df = filter(Wetlands.spdf@data, NWIsw == 1)
BSnwi = c(mean((BSNWI.df$M0Prob - 1)^2), mean((BSNWI.df$M1Prob - 1)^2),
        mean((BSNWI.df$M2Prob - 1)^2), mean((BSNWI.df$M3Prob - 1)^2),
        mean((BSNWI.df$M4Prob - 1)^2), mean((BSNWI.df$M5Prob - 1)^2),
        mean((BSNWI.df$M6Prob - 1)^2), mean((BSNWI.df$M7Prob - 1)^2),
        mean((BSNWI.df$M8Prob - 1)^2), mean((BSNWI.df$M9Prob - 1)^2),
        mean((BSNWI.df$M10Prob - 1)^2), mean((BSNWI.df$M11Prob - 1)^2),
        mean((BSNWI.df$M12Prob - 1)^2), mean((BSNWI.df$M13Prob - 1)^2),
        mean((BSNWI.df$M14Prob - 1)^2), mean((BSNWI.df$M15Prob - 1)^2),
        mean((BSNWI.df$M16Prob - 1)^2))

ModelNWI = as.data.frame(cbind(MODEL = Models,
                               BSnwi = round(BSnwi, 3)))

NWIwCells = length(BSNWI.df$NWIsw)

MwCells.df = filter(Wetlands.spdf@data, 
                    M16Prob >= 0.5)

MwCells = length(MwCells.df$M16Prob)

WetDiffsw = ((MwCells - NWIwCells)/NWIwCells)*100

NWIwCells
MwCells
WetDiffsw

ModelNWI



NW_NWIcnt = sum(Wetlands.spdf@data$NWInw)   
WetDiffnw = ((NW_M7cnt - NW_NWIcnt)/NW_NWIcnt)*100

NW_M7cnt
NW_NWIcnt 
WetDiffnw
```

```{r}
rm(list=setdiff(ls(), c("model7", "model7_30", "model7_70", "model7_200", "M7_NW",
                        "model7_300", "Brier", "M7_SW", "M16_SW")))
```


End of Script
--------------





